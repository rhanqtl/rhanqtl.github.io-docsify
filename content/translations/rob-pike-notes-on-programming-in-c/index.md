---
title: "[WIP][译] Rob Pike: Notes on Programming in C"
date: 2022-08-14T16:25:08+08:00
draft: false
summary: \-
---

> 译者按：这篇文章是 Rob Pike（Go 语言之父）在 1989 年写的一篇关于代码风格的文章，很有价值，因此翻译为中文，希望能够让更多的人看到。翻译采用直译加意译的风格，水平有限，欢迎发邮件到 [my@rhanqtl.com](mailto:my@rhanqtl.com) 批评指正。


# 引言

Kernighan 和 Plauger 的《The Elements of Programming Style》重要且确有影响力的书，但有时我觉得它的简明规则被视为一种达到良好风格的硬性规定，而不是它们本应成为的哲学的简洁表达。如果这本书声称应该有意义地选择变量名称，那么难道不是说名称是关于其使用的小论文的变量更好吗？`MaximumValueUntilOverflow` 不是比 `maxval` 更好的名字吗？我不作如是观。

接下来是一组短文，它们共同鼓励编程中的清晰哲学，而不是给出硬性规则。我不指望你同意所有这些，因为它们是观点，观点随着时代的变化而变化。但是它们一直在我的脑海中积累，如果直到现在还没有写在纸上，很长一段时间，并且是基于大量的经验，所以我希望它们能帮助你理解如何规划一个程序的细节（我还没有看到一篇关于如何计划整个事情的好文章，但这就是这门课程的部分内容）。如果你发现它们很特别，很好；如果你不同意他们，没关系；但如果他们让你思考你为什么不同意，那就更好了。在任何情况下，你都不应该因为我说要这样做就这样做；以你认为最能表达你在程序中想要完成的内容的方式进行编程，并始终如一地无情地这样做。

欢迎您的意见。

# 排版问题

程序是一种出版物，它首先会被作者自己阅读然后可能被另一个程序员（可能是几天、几周或几年后的你自己）阅读，最后才会被机器阅读。机器并不关心程序有多漂亮——如果程序编译，机器就会高兴——但人们会关心，而且他们应该这样做。有时他们太在意了：漂亮打印程序[^pretty-printers]会机械地产生漂亮的输出，突出程序中不相关的细节，这就像把中文文本[^english-chinese] *中* 的所有介词都加粗一样“明智”。尽管许多人认为程序应该看起来像 Algol-68 报告（有些系统甚至要求您以这种风格编辑程序），但这样的呈现并没有使清晰的程序更清晰，却使糟糕的程序更可笑。

[^pretty-printers]: 原文为“pretty printers”

[^english-chinese]: 原文直译为“英文文本”

当然，一贯坚持的排版约定对于清晰的呈现很重要——缩进可能是最著名和最有用的例子——但是当墨水掩盖了意图时，排版就占据了主导地位。因此，即使您坚持使用类似老式打字机的普通输出，也要注意印刷是否愚蠢。避免装饰，例如，保持注释简短且没有横幅。整齐而一致地在程序中说完你想说，然后继续前进。

# 变量名称

啊，变量名……名字不是越长越好，重要的是清晰[^variable-names-virtue]。一个很少使用的全局变量应该有一个长名字，例如 `maxphysaddr`。然而，循环中频繁使用的数组索引就不需要比 `i` 更复杂的名字，像 `index` 和 `elementnumber` 这样的名字只能让你或你的文本编辑器多打些字，还会妨碍对于计算的细节的理解。相较于短变量名，长变量名会使得读者更难理解代码的含义[^whats-going-on]。这在某种程度上是一个排版问题，考虑如下两段代码：

[^variable-names-virtue]: Length is not a virtue in a name; clarity of expression is.

[^whats-going-on]: ..., it's harder to see what's going on.

```c
for (i=0 to 100)
    array[i] = 0
```

和

```c
for (elementnumber=0 to 100)
    array[elementnumber] = 0
```

在真实案例中，这种情况恶化得更快。索引仅仅是一个记号，像这样处理它们就行了。

指针同样需要有意义的记号。在某些命名约定中，`np` 表示 `nodepointer`，如果你总是使用一致的命名约定，那么对于你而言 `np` 与 `nodepointer` 就会有相同的含义。下一篇文章会更多地设计这方面内容。

如同可读编程的所有其他方面，一致性在命名中是相当重要的。如果你将一个变量命名为 `maxphysaddr`，就不要将其对应物命名为 `lowestaddress`[^maxphysaddr-cousin]。

[^maxphysaddr-cousin]: 我猜应该叫 `minphysaddr`

最后，我倾向于使用信息-长度比最高的名字[^info-length-ratio]，并且让该名字所处的上下文提供额外的信息。例如，全局变量在被使用时通常只有很少的上下文，因此他们的名字就得相对更有提示性[^evocative]。因此，对于全局变量，我会使用 `maxphysaddr`（而不是 `MaximumPhysicalAddress`）这样的名字，而对于局部定义和使用的指针，我会使用 `np`（而不是 `NodePointer`）这样的名字。这仅仅是品味的问题，然而品味与清晰程度有关系。

[^info-length-ratio]: 原文是“minimum-length but maximum-information names”，此处意译

[^evocative]: evocative

我在命名时会尽量避免使用大写字母，对于我 prose-oriented 的双眼，它们过于奇怪，读起来不舒服，就像不好的排版那样。

# 指针的使用

C 的不同之处在于它允许指针指向任何东西。指针是锐利的工具，而且就像所有的锐利的工具那样，如果能够用好它们，就会得到很高的生产力，相反，如果用不好，它们就会产生巨大的破坏（在写这篇文章的前几天，我刚刚被一把木凿弄伤了拇指）。指针在学术界的名声不太好，因为他们被认为是太危险且有点 dirty。但是，我认为他们是非常强大的记号，也就是说，它们能帮助我们更清晰地表达。

考虑：当你有一个指针时，它是且仅是那个对象的一个名字。这听起来很平常，但是看看下面的两个表达式：

```plaintext
np
node[i]
```

第一个表达式指向一个节点，第二个表达式的求值结果为同一个节点。然而，第二种形式是一个表达式，不够简单——为了解释这个表达式，我们需要根据上下文中的规则（可能并未明确定义）知道 `node` 是什么、`i` 是什么以及 `i` 和 `node` 是有关的。表达式中的任一部分都不能单独地证明 `i` 是 `node` 合法的索引，更不用说能否证明 `i` 是否是我们想要的那个元素的索引。如果 `i` `j` `k` 都是 `node` 这个数组的索引，很容易就会搞混，而且编译器也帮不上什么忙。这样就很容易在给子例程传递参数时犯错：一个指针是一个单独的事物，而一个数组和一个索引在接受子例程中则必须被认为是相关联的。

一个求值为对象的表达式有固有的微妙性，且相比于对象的地址更容易出错。正确使用指针能够简化代码：

```c
parent->link[i].type
```

对比

```c
lp->type
```

如果我们需要下一个元素的类型：

```c
parent->link[++i].type
```

或

```c
(++lp)->type
```

在前一种形式中，只有 `i` 前进了，其余的部分保持不变，而在使用指针的第一种形式中，只有一个事物能够前进。

排版上的考虑在这里同样适用。使用指针遍历结构比使用表达式容易读得多：需要的字符更少，编译器和计算机的工作量也更少。一个相关的问题是指针的类型会影响它被如何正确地使用，这给有用的编译器错误检查创造了条件，而数组却不能做到这一点。同样，如果对象是结构体，它们的字段是他们类型的提示，因此

```c
np->left
```

足够唤起读者的记忆。如果使用数组，则必须精心选择数组的名字，最后的表达式也会更长：

```
node[i].left
```

同样地，多余的字符在程序变大时会更恼人。

一条规则是，如果你发现了包含求值为数据结构的元素的很多相似且复杂的表达式的代码，合理地使用指针可以将其变得清晰。考虑：

```
if (goleft)
    p->left = p->right->left
else
    p->right = p->left->right
```

如果使用对应的符合表达式会变成什么样子。有时，可以使用一个临时变量（这里就是 `p`），或者一个宏来提高计算的抽象程度[^distill-the-calculation]。

[^distill-the-calculation]: distill the calculation

# 过程名称

过程名应该反映出它们的工作，函数名应该反映出它们 _返回_ 什么[^procedure-and-function]。函数在表达式中使用，通常是像 `if` 之类的地方，因此他们需要能够让读起来通顺：

```
if (checksize(x))
```

没有什么帮助，因为我们不能推断出 `checksize` 在何时（出错还是为出错）时返回 `true`；而

```
if (validsize(x))
```

则明确了这一点，使得未来在使用此例程时更不容易犯错。

[^procedure-and-function]: 

# 注释

注释是相当精妙的部分，需要程序员有良好的品味和判断能力。我倾向于尽可能减少注释，有如下的原因。其一，如果代码足够清晰，使用了良好的类型名称和变量名称，那么它应该能够自我解释。其二，编译器不会检查注释，因此无法保证他们是正确的，尤其是在代码发生变更之后[^comments-are-not-checked-by-the-compiler]。有误导性的注释会非常的令人困惑。其三，排版问题：注释使得代码杂乱无章。

[^comments-are-not-checked-by-the-compiler]: Rust 支持“文档测试”（见 [Documentation tests | The rustdoc book](https://doc.rust-lang.org/rustdoc/write-documentation/documentation-tests.html#:~:text=rustdoc%20supports%20executing%20your%20documentation%20examples%20as%20tests.,example%2C%20and%20then%20run%20it%20as%20a%20test.)），部分地保证了文档的正确性

但我有时候也进行注释。我几乎只在需要对下面进行简介的时候使用注释。例如，解释全局变量和类型的使用（我在大型程序中总是就这一点写注释）、介绍不常见或关键的过程以及给大型的计算过程划分段落。

有一种臭名昭著的注释风格：

```
i = i + 1;    /* Add one to i */
```

这还不是最坏的：

```
/**********************************
 *                                *
 *          Add one to i          *
 *                                *
 **********************************/
i = i + 1;
```

先别急着笑，等你在真实的代码中看到了再笑。

在注释中尽量避免漂亮的排版、避免大块注释——除非在像对核心数据结构的声明这样关键的部分（在数据结构上的注释往往比在算法上的注释更有帮助），当然，最好尽量避免注释。如果你的代码需要注释才能被理解，最好进行重写，提高其可理解性。这就涉及到了——

# 复杂性 Complexity

大多数程序都过于复杂，即，比高效解决它们的问题所需的复杂度更高。为什么？大多数情况下是因为不好的设计，但是在这里我会跳过这个太大的话题。然而，程序在微观层面上通常很复杂，这是我可以在这里解决的问题。

- 规则 1：你无法判断程序将把时间花在哪里。瓶颈常常出现在令人惊讶的地方，所以在你证明瓶颈在哪里之前，不要试图猜测并进行速度破解。
- 规则 2：度量。在度量之前不要优化速度，即使进行了度量，除非代码的一部分压倒了其余部分，也不要去进行优化。
- 规则 3：当 `n` 很小时，花哨的算法很慢，而 `n` 通常很小。花哨的算法有很大的常数。在你知道 `n` 经常会很大之前，不要让算法变得花哨（即使 n 确实变大了，首先使用规则 2）。例如，对于日常问题，二叉树总是比伸展树[^splay-tree]快。
- 规则 4。花哨的算法比简单的算法更容易出错，而且它们更难实现。使用简单的算法以及简单的数据结构。

[^splay-tree]: https://brilliant.org/wiki/splay-tree/

如下的数据结构对于几乎能够应对所有的现实问题：
- 数组
- 链表
- 散列表
- 二叉树

当然，你还必须准备好将这些整合到复合数据结构中。例如，可以将符号表实现为包含字符数组的链表的散列表。

- 规则 5：数据占主导地位。如果您选择了正确的数据结构并将事物组织得很好，那么算法几乎总是不言自明的。数据结构，而不是算法，是编程的核心（参见[《人月神话：F. P. Brooks 的软件工程论文集》](http://www.amazon.com/gp/product/0201835959?ie=UTF8&tag=catv-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=0201835959)，第 102 页）
- 规则 6：没有规则 6。

# 面向数据编程 Programming with data

算法，或称为算法的细节通常可以紧凑、高效和富有表达力地编码为数据，例如，大量的 if 语句。原因是手头工作的复杂性可以编码，如果是由于独立细节的组合。一个典型的例子是解析表[^parsing-table]，它将编程语言的文法[^grammar]编码为可以由一段固定的、相当简单的代码解释的形式。有限状态机特别适合这种形式的攻击，但几乎任何涉及将某种抽象类型的输入“解析”为一系列独立“动作”的程序都可以构建为数据驱动的算法。

也许这种设计最耐人寻味的方面是表格有时可以由另一个程序生成——在经典案例中是解析器生成器[^parser-generator]。作为一个更实际的例子，如果一个操作系统是由一组将 I/O 请求连接到适当的设备驱动程序的表驱动的，则系统可能由一个读取连接到该机器的特定设备的描述并打印对应表格的程序“配置”。

至少在初学者中，数据驱动程序不常见的原因之一是 Pascal 的专制。 Pascal 和它的创建者一样，坚信代码和数据的分离。因此，它（至少以其原始形式）无法创建初始化数据。这与定义了存储程序计算机的基本原理的图灵和冯·诺依曼的理论背道而驰。_代码和数据是相同的_，或者至少它们可以是相同的。你还能如何解释编译器的工作原理（函数式语言在 I/O 方面也有类似的问题）？

[^parsing-table]: 原文为“parsing table”

[^grammar]: 原文为“grammar”，通常翻译为“文法”，“语法”一般对应于“syntax”

[^parser-generator]: 原文为“parser generator”

# 函数指针 Function pointers

Pascal 暴政的另一个结果是初学者不使用函数指针（在 Pascal 中不能有函数值变量）。使用函数指针来编码复杂性有一些有趣的特性。

一些复杂性被传递给所指向的例程。例程必须遵守一些标准协议——它是一组被相同调用的例程之一——但除此之外，它所做的只是它的业务。复杂性是分布的[^distributed]。

[^distributed]: 原文为“distributed”

有一个协议的想法，因为所有类似使用的函数都必须表现类似。这使得文档、测试、增长变得容易，甚至使程序在网络上分布运行——协议可以编码为远程过程调用。

我认为清晰地使用函数指针是面向对象编程的核心。给定您想要对数据执行的一组操作，以及您想要响应这些操作的一组数据类型，将程序放在一起的最简单方法是为每种类型使用一组函数指针。简而言之，这定义了类和方法。面向对象语言当然会给你更多——更漂亮的语法、派生类型等等——但从概念上讲，它们几乎没有提供额外的东西。

将数据驱动程序与函数指针相结合会产生一种令人惊讶的有表达力的方式，根据我的经验，这种方式经常会带来惊喜。即使没有特殊的面向对象语言，您也可以获得 90% 的收益而不需要额外的工作，并且可以更好地控制结果。我不能更高度地推荐一种实现风格。我以这种方式组织的所有程序在经过大量开发后都安然无恙地存活了下来——远比不那么规范的方法要好得多。也许就是这样：从长远来看，它强制执行的纪律会带来丰厚的回报。

# 包含文件 Include files

简单的规则：包含文件不应该包含包含文件。相反，如果他们声明（在注释中或隐含地）他们需要首先包含哪些文件，则决定要包含哪些文件的问题被推送给用户（程序员），但以一种易于处理的方式，并且通过构造避免多重包含[^multiple-inclusions]。多重包含是系统编程的祸根。编译单个 C 源文件时包含五次或更多次的文件并不罕见。UNIX 中 `/usr/include/sys` 这样的东西很糟糕。

[^multiple-inclusions]: 原文为“multiple inclusions”

有一些涉及 `#ifdef` 的小技巧可以防止文件被读取两次，但在实践中通常做错了——`#ifdef` 存在于文件本身中，而不是包含它的文件中。结果通常是数千行不必要的代码通过词法分析器，这是（在好的编译器中）最昂贵的阶段。

只需遵循简单的规则。

