<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>rhanqtl – Notes</title>
    <link>/notes/</link>
    <description>Recent content in Notes on rhanqtl</description>
    <generator>Hugo -- gohugo.io</generator>
    
	  <atom:link href="/notes/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
      
    
    
    <item>
      <title>Notes: </title>
      <link>/notes/compilers/analysis/ssa/dominance/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/notes/compilers/analysis/ssa/dominance/</guid>
      <description>
        
        
        &lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_dominate&#34;&gt;Dominate&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;在 CFG 中，顶点 n1 dominate 顶点 n2 意味着：从 entry 块到 BB n2 的每一条路径上都有&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

      </description>
    </item>
    
    <item>
      <title>Notes: </title>
      <link>/notes/misc/what-is-a-pl-research/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/notes/misc/what-is-a-pl-research/</guid>
      <description>
        
        
        &lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;文章首先用华盛顿大学（University of Washington，UW）雇佣了不少 PL 专家引出这样一个观点：PL 研究者能够在重要问题上有巨大的进展，能够带来解锁新结果的有用的观点。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;为什么要做 PL 研究？&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;ulist&#34;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;有意思&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;有回报：能够学到东西，越来越多的机会&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;PL 研究不仅仅是设计语言。一个 PL 研究者是将程序设计语言看作解决计算问题的中心部分的人。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;PL 研究者通常集中于开发用于解决问题、或问题类的通用抽象（general abstraction）或者说基本构建块（building blocks）&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;PL 研究也以严格和一般的方式考虑软件行为&lt;/p&gt;
&lt;/div&gt;

      </description>
    </item>
    
    <item>
      <title>Notes: </title>
      <link>/notes/reading-yash-code/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/notes/reading-yash-code/</guid>
      <description>
        
        
        
      </description>
    </item>
    
    <item>
      <title>Notes: </title>
      <link>/notes/ruby-under-a-microscope/chap03/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/notes/ruby-under-a-microscope/chap03/</guid>
      <description>
        
        
        
      </description>
    </item>
    
    <item>
      <title>Notes: 第五章 IR</title>
      <link>/notes/compilers/engineering-a-compiler/05-ir/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/notes/compilers/engineering-a-compiler/05-ir/</guid>
      <description>
        
        
        &lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-plantuml&#34; data-lang=&#34;plantuml&#34;&gt;@startmindmap

* IR

** Aspects
*** structural organization
*** level of abstraction
*** expressiveness

** Tree-like IR&amp;#39;s
*** most near-source-level
*** reflects the grammar structure
*** more memory

** DAG
*** eliminate redundancies, more compact than tree-like IR&amp;#39;s
*** suggest evaluation order

** CFG
*** &amp;lt;b&amp;gt;Structure&amp;lt;/b&amp;gt;
**** &amp;lt;b&amp;gt;Node:&amp;lt;/b&amp;gt; basic block
**** &amp;lt;b&amp;gt;Edges:&amp;lt;/b&amp;gt; control-flow transfer
*** &amp;lt;b&amp;gt;Aspects&amp;lt;/b&amp;gt;
**** shows runtime control-flow paths


@endmindmap
&lt;/code&gt;&lt;/pre&gt;
      </description>
    </item>
    
  </channel>
</rss>
