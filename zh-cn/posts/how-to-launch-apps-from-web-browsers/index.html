<!doctype html><html lang=zh-cn><head><title>如何从浏览器启动应用程序 · rhanqtl</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="rhanqtl"><meta name=description content="-"><meta name=keywords content="blog,developer,personal,博客,开发者,个人网站"><meta name=twitter:card content="summary"><meta name=twitter:title content="如何从浏览器启动应用程序"><meta name=twitter:description content="-"><meta property="og:title" content="如何从浏览器启动应用程序"><meta property="og:description" content="-"><meta property="og:type" content="article"><meta property="og:url" content="https://rhanqtl.github.io/posts/how-to-launch-apps-from-web-browsers/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-12-30T21:50:11+08:00"><meta property="article:modified_time" content="2022-12-30T21:50:11+08:00"><link rel=canonical href=https://rhanqtl.github.io/posts/how-to-launch-apps-from-web-browsers/><link rel=preload href="/fonts/forkawesome-webfont.woff2?v=1.2.0" as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.0669b62fc2c181a12a4ba10be9984e385c9a5e83dc7cb7ae3759ad0b98d7e8b2.css integrity="sha256-Bmm2L8LBgaEqS6EL6ZhOOFyaXoPcfLeuN1mtC5jX6LI=" crossorigin=anonymous media=screen><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5><meta name=generator content="Hugo 0.111.2"></head><body class="preload-transitions colorscheme-light"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=/>rhanqtl</a>
<input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/posts/>原创博文</a></li><li class=navigation-item><a class=navigation-link href=/translations/>翻译</a></li><li class=navigation-item><a class=navigation-link href=/poems/>喜欢的诗歌</a></li><li class=navigation-item><a class=navigation-link href=/projects/>作品</a></li><li class=navigation-item><a class=navigation-link href=/about/>关于我</a></li><li class="navigation-item menu-separator"><span>|</span></li><li class=navigation-item><a href=/en/></a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://rhanqtl.github.io/posts/how-to-launch-apps-from-web-browsers/>如何从浏览器启动应用程序</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa fa-calendar" aria-hidden=true></i>
<time datetime=2022-12-30T21:50:11+08:00>December 30, 2022</time></span>
<span class=reading-time><i class="fa fa-clock-o" aria-hidden=true></i>
阅读时间：3 分钟</span></div></div></header><div class=post-content><h1 id=导言>导言
<a class=heading-link href=#%e5%af%bc%e8%a8%80><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h1><p>你一定遇到过这样的情况：点击网页中的一个链接，会弹出一个对话框，问你能否打开本地的某个应用程序。</p><p><img src=./images/open-vscode-from-browser.png alt></p><p>本文探究 Windows 系统中这种功能的原理。</p><h1 id=windows-注册表>Windows 注册表
<a class=heading-link href=#windows-%e6%b3%a8%e5%86%8c%e8%a1%a8><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h1><p>归根到底，上面所说的功能是基于 Windows 的注册表来实现的，因此我们需要对注册表有基本的了解。</p><p>MSDN 对注册表的解释如下：</p><p><em>注册表</em> 是系统定义的数据库，为应用程序和系统组件提供了存储和检索配置数据的功能。存储在注册表中的数据因 Windows 的版本而异。应用程序使用注册表 API 来检索、修改或删除注册表数据。</p><blockquote><p>The <em>registry</em> is a system-defined database in which applications and system components store and retrieve configuration data. The data stored in the registry varies according to the version of Microsoft Windows. Applications use the registry API to retrieve, modify, or delete registry data.</p></blockquote><h2 id=注册表的结构>注册表的结构
<a class=heading-link href=#%e6%b3%a8%e5%86%8c%e8%a1%a8%e7%9a%84%e7%bb%93%e6%9e%84><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h2><p>注册表中的数据采用树的形式组织。树中的节点称为“键”。一个键可以包含“子键”和被称为“值”的数据项。一个注册表树的最大深度为 512。一个键可以包含任意数量的值，一个值可以是任何形式。</p><blockquote><p>The data is structured in a tree format. Each node in the tree is called a <em>key</em>. Each key can contain both <em>subkeys</em> and data entries called <em>values</em>.</p><p>A registry tree can be 512 levels deep.</p><p>A key can have any number of values, and the values can be in any form.</p></blockquote><p>用 OCaml 表示，大概是这样的结构：</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#ff7b72>type</span> registry <span style=color:#ff7b72;font-weight:700>=</span> key <span style=color:#ff7b72>list</span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>type</span> key <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#ff7b72;font-weight:700>{</span> subkeys <span style=color:#ff7b72;font-weight:700>:</span> key <span style=color:#ff7b72>list</span><span style=color:#ff7b72;font-weight:700>;</span> values <span style=color:#ff7b72;font-weight:700>:</span> <span style=color:#ff7b72>string</span> <span style=color:#ff7b72>list</span> <span style=color:#ff7b72;font-weight:700>}</span>
</span></span></code></pre></div><p>每个键的名字由一个或多个<a href=https://en.wikipedia.org/wiki/PrintableString class=external-link target=_blank rel=noopener>可打印字符</a>
组成，但是不能包含反斜杠 <code>\</code>。键名不是大小写敏感的。值的名字和数据可以包含反斜杠。一个键的所有直接子键的名字必须是唯一的。键名不会本地化为其他语言，但是值名可以。</p><blockquote><p>Each key has a name consisting of one or more printable characters. Key names are not case sensitive. Key names cannot include the backslash character (\), but any other printable character can be used. Value names and data can include the backslash character.</p><p>The name of each subkey is unique with respect to the key that is immediately above it in the hierarchy. Key names are not localized into other languages, although values may be.</p></blockquote><p>每个值由三部分组成：名字、类型和值。其中，每个键都会有一个默认为空的值，其他的所有值都必须不为空。</p><p>值的类型有 6 种：</p><ul><li><code>REG_BINARY</code> &ndash; 二进制数据</li><li><code>REG_DWORD</code> &ndash; 4 字节整数</li><li><code>REG_QWORD</code> &ndash; 8 字节整数</li><li><code>REG_SZ</code> &ndash; 以 <code>NUL</code> 结尾的字符串</li><li><code>REG_EXPAND_SZ</code> &ndash; 以 <code>NUL</code> 结尾的字符串，其中环境变量不会展开</li><li><code>REG_MULTI_SZ</code> &ndash; 以 <code>NUL</code> 结尾的字符串数组，示例：<code>string1\0string2\0string3\0\0</code>，最后一个 <code>NUL</code> 用于结束整个序列</li></ul><p>官方文档的示例：</p><p><img src=https://learn.microsoft.com/en-us/windows/win32/sysinfo/images/regtree.png alt></p><p>其中“My Computer”下面的每一个树都是一个键，其中 <code>HKEY_LOCAL_MACHINE</code> 包含如下的子键：<code>HARDWARD</code> <code>SAM</code> <code>SECURITY</code> <code>SOFTWARE</code> <code>SYSTEM</code>，这些子键又有各自的子键。例如，<code>HARDWARD</code> 的子键为 <code>DESCRIPTION</code> <code>DEVICEMAP</code> <code>RESOURCEMAP</code>。</p><h2 id=预定义键>预定义键
<a class=heading-link href=#%e9%a2%84%e5%ae%9a%e4%b9%89%e9%94%ae><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h2><p>预定义键是应用程序访问注册表的<strong>唯一</strong>入口</p><h3 id=hkey_classes_root>HKEY_CLASSES_ROOT
<a class=heading-link href=#hkey_classes_root><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h3><p>包含文件扩展名关联和 COM 类注册信息（例如，在 Windows 中安装软件后时常会遇到提示“选择关联文件类型”）。</p><p>文件扩展名和类注册信息存储在 <code>HKEY_LOCAL_MACHINE</code> 和 <code>HKEY_CURRENT_USER</code> 键下。<code>HKEY_LOCAL_MACHINE\Software\Classes</code> 项包含用于本地计算机上所有用户的默认设置；<code>HKEY_CURRENT_USER\Software\Classes</code> 项包含仅用于当前用户的设置。而 <code>HKEY_CLASSES_ROOT</code> 键提供了合并来自这两个来源的信息的注册表视图，还为以前版本的 Windows 设计的应用程序提供此合并视图。主要是为了与 16 位 Windows 兼容。</p><h3 id=hkey_current_user>HKEY_CURRENT_USER
<a class=heading-link href=#hkey_current_user><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h3><p>例如，启动 Visual Studio Code 的相关配置：</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Windows Registry Editor Version 5.00
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>[HKEY_CURRENT_USER\Software\Classes\vscode]
</span></span><span style=display:flex><span>&#34;URL Protocol&#34;=&#34;&#34;
</span></span><span style=display:flex><span>@=&#34;URL:vscode&#34;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>[HKEY_CURRENT_USER\Software\Classes\vscode\shell]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>[HKEY_CURRENT_USER\Software\Classes\vscode\shell\open]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>[HKEY_CURRENT_USER\Software\Classes\vscode\shell\open\command]
</span></span><span style=display:flex><span>@=&#34;\&#34;C:\\Program Files\\Microsoft VS Code\\Code.exe\&#34; \&#34;--open-url\&#34;  \&#34;--\&#34; \&#34;%1\&#34;&#34;
</span></span></code></pre></div><p>其中 <code>@</code> 就是默认生成的名字为空的值，<code>[HKEY_CURRENT_USER\Software\Classes\vscode]</code> 下 <code>@</code> 表示关联的 URL scheme，<code>[HKEY_CURRENT_USER\Software\Classes\vscode\shell\open\command]</code> 下的 <code>@</code> 表示启动命令，其中 <code>%1</code> 为 <code>vscode://</code> 后的部分</p><blockquote><p><code>%1</code> 这种表示法来自 Windows 的批处理（<code>.bat</code>）文件，表示脚本的第一个参数，类似 Bash 的 <code>$1</code></p></blockquote><h1 id=从浏览器启动应用程序的原理>从浏览器启动应用程序的原理
<a class=heading-link href=#%e4%bb%8e%e6%b5%8f%e8%a7%88%e5%99%a8%e5%90%af%e5%8a%a8%e5%ba%94%e7%94%a8%e7%a8%8b%e5%ba%8f%e7%9a%84%e5%8e%9f%e7%90%86><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h1><h2 id=在注册表中添加配置>在注册表中添加配置
<a class=heading-link href=#%e5%9c%a8%e6%b3%a8%e5%86%8c%e8%a1%a8%e4%b8%ad%e6%b7%bb%e5%8a%a0%e9%85%8d%e7%bd%ae><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h2><p>如前面贴的例子所示</p><h2 id=demo>Demo
<a class=heading-link href=#demo><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h2><p>我们写一个简单的程序：</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#8b949e;font-style:italic># -*- coding: UTF-8 -*-</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a5d6ff>&#34;&#34;&#34;模仿 Visual Studio Code 实现一个多入口的计算器&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>import</span> <span style=color:#ff7b72>argparse</span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>import</span> <span style=color:#ff7b72>sys</span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>import</span> <span style=color:#ff7b72>urllib.parse</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>if</span> __name__ <span style=color:#ff7b72;font-weight:700>==</span> <span style=color:#a5d6ff>&#34;__main__&#34;</span>:
</span></span><span style=display:flex><span>    parser <span style=color:#ff7b72;font-weight:700>=</span> argparse<span style=color:#ff7b72;font-weight:700>.</span>ArgumentParser()
</span></span><span style=display:flex><span>    parser<span style=color:#ff7b72;font-weight:700>.</span>add_argument(<span style=color:#a5d6ff>&#34;--from-url&#34;</span>, type<span style=color:#ff7b72;font-weight:700>=</span>str)
</span></span><span style=display:flex><span>    args <span style=color:#ff7b72;font-weight:700>=</span> parser<span style=color:#ff7b72;font-weight:700>.</span>parse_args()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>try</span>:
</span></span><span style=display:flex><span>        url <span style=color:#ff7b72;font-weight:700>=</span> urllib<span style=color:#ff7b72;font-weight:700>.</span>parse<span style=color:#ff7b72;font-weight:700>.</span>urlparse(args<span style=color:#ff7b72;font-weight:700>.</span>from_url)
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>if</span> url<span style=color:#ff7b72;font-weight:700>.</span>hostname <span style=color:#ff7b72;font-weight:700>!=</span> <span style=color:#a5d6ff>&#34;eval&#34;</span>:
</span></span><span style=display:flex><span>            <span style=color:#ff7b72>raise</span> <span style=color:#f0883e;font-weight:700>Exception</span>(<span style=color:#a5d6ff>&#34;unsupported action: </span><span style=color:#a5d6ff>{}</span><span style=color:#a5d6ff>&#34;</span><span style=color:#ff7b72;font-weight:700>.</span>format(url<span style=color:#ff7b72;font-weight:700>.</span>hostname))
</span></span><span style=display:flex><span>        expr <span style=color:#ff7b72;font-weight:700>=</span> url<span style=color:#ff7b72;font-weight:700>.</span>query<span style=color:#ff7b72;font-weight:700>.</span>split(<span style=color:#a5d6ff>&#34;&amp;&#34;</span>)[<span style=color:#a5d6ff>0</span>]<span style=color:#ff7b72;font-weight:700>.</span>split(<span style=color:#a5d6ff>&#34;=&#34;</span>, <span style=color:#a5d6ff>1</span>)[<span style=color:#a5d6ff>1</span>]
</span></span><span style=display:flex><span>        print(<span style=color:#a5d6ff>&#34;&#39;</span><span style=color:#a5d6ff>{}</span><span style=color:#a5d6ff>&#39; is </span><span style=color:#a5d6ff>{}</span><span style=color:#a5d6ff>&#34;</span><span style=color:#ff7b72;font-weight:700>.</span>format(expr, eval(expr)))
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>except</span> <span style=color:#f0883e;font-weight:700>Exception</span> <span style=color:#ff7b72>as</span> exn:
</span></span><span style=display:flex><span>        print(exn)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    input(<span style=color:#a5d6ff>&#34;</span><span style=color:#79c0ff>\n</span><span style=color:#a5d6ff>Press ENTER key to exit&#34;</span>)
</span></span></code></pre></div><p>确保在注册表的 <code>HKEY_CURRENT_USER\Software\Classes</code> 下创建如下的键</p><pre tabindex=0><code>Windows Registry Editor Version 5.00

[HKEY_CURRENT_USER\Software\Classes\demo]
@=&#34;URL:demo&#34;
&#34;URL Protocol&#34;=&#34;&#34;

[HKEY_CURRENT_USER\Software\Classes\demo\shell]

[HKEY_CURRENT_USER\Software\Classes\demo\shell\open]

[HKEY_CURRENT_USER\Software\Classes\demo\shell\open\command]
@=&#34;\&#34;${PYTHON}\&#34; \&#34;${CODE_DIR}\\demo.py\&#34; \&#34;--from-url\&#34; \&#34;%1\&#34;
</code></pre><p>注意将 <code>${PYTHON}</code> 和 <code>${CODE_DIR}</code> 分别替换为 Python 解释器的绝对路径和 <code>demo.py</code> 所在的目录，然后在浏览器中访问 <code>demo://eval?expr=1+2</code> 就可以看到效果</p><p><img src=./images/demo.png alt></p><h2 id=浏览器做了什么>浏览器做了什么？
<a class=heading-link href=#%e6%b5%8f%e8%a7%88%e5%99%a8%e5%81%9a%e4%ba%86%e4%bb%80%e4%b9%88><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h2><p>如果尝试一下没有注册的 URL scheme 并且也不是 <code>http</code> 这种已经有含义的（不过实际上 <code>http</code> 也是有相应注册表项的，只不过没有关联命令），你会发现 Chrome 会使用默认搜索引擎搜索：</p><p><img src=images/non-registered-url-scheme-1.png alt></p><blockquote><p>这里没用 <code>search://</code> 是因为已经被文件浏览器占用了</p></blockquote><p><img src=images/non-registered-url-scheme-2.png alt></p><p>你一定会好奇：浏览器怎么知道要打开应用程序而不是直接搜索？</p><p>// TODO (Chromium 源码太大了多少有点顶不住)</p><blockquote><p>不过我在 Chromium 的源码中发现了一组预定义的 <code>vector</code>：</p><p><img src=./images/chromium-standard_schemes.png alt></p><p>猜测应该是解析完 URL 之后，判断 URL scheme 是不是预定义的，如果不是，在 Windows 上就会访问注册表</p></blockquote><h1 id=参考>参考
<a class=heading-link href=#%e5%8f%82%e8%80%83><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h1><ol><li><a href=https://learn.microsoft.com/en-us/windows/win32/sysinfo/registry class=external-link target=_blank rel=noopener>Registry | Windows App Development</a></li><li><a href=https://learn.microsoft.com/en-us/windows/win32/sysinfo/registry-value-types class=external-link target=_blank rel=noopener>Registry Value Types | Windows App Development</a>
介绍了注册表中值的类型</li><li><a href="https://learn.microsoft.com/en-us/previous-versions/windows/internet-explorer/ie-developer/platform-apis/aa767914%28v=vs.85%29?redirectedfrom=MSDN" class=external-link target=_blank rel=noopener>这篇文档</a>
是微软官方关于注册自定义 URL scheme 的指南（MSDN 真是什么都有呢！）</li><li>通过浏览器启动应用的相关文章<ul><li><a href=https://segmentfault.com/a/1190000040237895 class=external-link target=_blank rel=noopener>如何在网页上打开本地应用</a></li><li><a href=https://juejin.cn/post/6844903989155217421 class=external-link target=_blank rel=noopener>前端网页如何打开一个PC本地应用</a></li><li>比较简练：<a href=https://juejin.cn/post/6945016587992694821 class=external-link target=_blank rel=noopener>网页如何唤起应用程序？</a></li></ul></li><li>关于 URL 的完整结构，可以参考 MDN 的 <a href=https://developer.mozilla.org/en-US/docs/Learn/Common_questions/What_is_a_URL class=external-link target=_blank rel=noopener>What is a URL?</a>
和 Wikipedia 的 <a href=https://en.wikipedia.org/wiki/URL#Syntax class=external-link target=_blank rel=noopener>URL</a></li></ol></div><footer></footer></article></section></div><footer class=footer><section class=container>©
2023
rhanqtl
·
技术支持 <a href=https://gohugo.io/>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/>Coder</a>.</section></footer></main><script src=/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script></body></html>