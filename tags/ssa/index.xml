<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>rhanqtl – SSA</title>
    <link>/tags/ssa/</link>
    <description>Recent content in SSA on rhanqtl</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Mon, 13 Mar 2023 10:25:27 +0800</lastBuildDate>
    
	  <atom:link href="/tags/ssa/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
      
    
    
    <item>
      <title>Posts: 构造 SSA 形式</title>
      <link>/posts/compilers/ssa-construction/</link>
      <pubDate>Mon, 13 Mar 2023 10:25:27 +0800</pubDate>
      
      <guid>/posts/compilers/ssa-construction/</guid>
      <description>
        
        
        &lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;转换到 SSA 形式大体上分为两个步骤：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;olist arabic&#34;&gt;
&lt;ol class=&#34;arabic&#34;&gt;
&lt;li&gt;
&lt;p&gt;插入 phi 函数，确保对于任意的变量 &lt;code&gt;v&lt;/code&gt;，&lt;code&gt;USES(v)&lt;/code&gt; 中的每一个点有且仅有 &lt;code&gt;v&lt;/code&gt; 的一个 reaching definition。这也称为“live-range splitting”；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;重命名 &lt;code&gt;v&lt;/code&gt; 的所有定义，给每个定义赋予唯一的名字（换言之，重命名 &lt;code&gt;v&lt;/code&gt; 的所有 live-range）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_dominance_frontier&#34;&gt;Dominance Frontier&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;用 &lt;code&gt;DF(n)&lt;/code&gt; 表示 &lt;code&gt;n&lt;/code&gt; 的 dominance frontier，其中元素 &lt;code&gt;x&lt;/code&gt; 为 &lt;code&gt;n&lt;/code&gt; dominate &lt;code&gt;x&lt;/code&gt; 的某个前驱顶点，但是不 strictly dominate &lt;code&gt;x&lt;/code&gt;。&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;fig:df-ex-1&#34; class=&#34;imageblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;img src=&#34;images/df-1.png&#34; alt=&#34;df 1&#34;/&gt;
&lt;/div&gt;
&lt;div class=&#34;title&#34;&gt;Figure 1. Dominance Frontier 例子（1）&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;其中：&lt;/p&gt;
&lt;/div&gt;
&lt;table class=&#34;tableblock frame-all grid-all stretch&#34;&gt;
&lt;colgroup&gt;
&lt;col style=&#34;width: 16.6666%;&#34;/&gt;
&lt;col style=&#34;width: 16.6666%;&#34;/&gt;
&lt;col style=&#34;width: 16.6666%;&#34;/&gt;
&lt;col style=&#34;width: 16.6666%;&#34;/&gt;
&lt;col style=&#34;width: 16.6666%;&#34;/&gt;
&lt;col style=&#34;width: 16.667%;&#34;/&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th class=&#34;tableblock halign-left valign-top&#34;&gt;n&lt;/th&gt;
&lt;th class=&#34;tableblock halign-left valign-top&#34;&gt;DOM&lt;/th&gt;
&lt;th class=&#34;tableblock halign-left valign-top&#34;&gt;DF&lt;/th&gt;
&lt;th class=&#34;tableblock halign-left valign-top&#34;&gt;n&lt;/th&gt;
&lt;th class=&#34;tableblock halign-left valign-top&#34;&gt;DOM&lt;/th&gt;
&lt;th class=&#34;tableblock halign-left valign-top&#34;&gt;DF&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&#34;tableblock halign-left valign-top&#34;&gt;&lt;p class=&#34;tableblock&#34;&gt;r&lt;/p&gt;&lt;/td&gt;
&lt;td class=&#34;tableblock halign-left valign-top&#34;&gt;&lt;p class=&#34;tableblock&#34;&gt;r&lt;/p&gt;&lt;/td&gt;
&lt;td class=&#34;tableblock halign-left valign-top&#34;&gt;&lt;p class=&#34;tableblock&#34;&gt;-&lt;/p&gt;&lt;/td&gt;
&lt;td class=&#34;tableblock halign-left valign-top&#34;&gt;&lt;p class=&#34;tableblock&#34;&gt;C&lt;/p&gt;&lt;/td&gt;
&lt;td class=&#34;tableblock halign-left valign-top&#34;&gt;&lt;p class=&#34;tableblock&#34;&gt;r, A, C&lt;/p&gt;&lt;/td&gt;
&lt;td class=&#34;tableblock halign-left valign-top&#34;&gt;&lt;p class=&#34;tableblock&#34;&gt;D, E&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&#34;tableblock halign-left valign-top&#34;&gt;&lt;p class=&#34;tableblock&#34;&gt;A&lt;/p&gt;&lt;/td&gt;
&lt;td class=&#34;tableblock halign-left valign-top&#34;&gt;&lt;p class=&#34;tableblock&#34;&gt;r, A&lt;/p&gt;&lt;/td&gt;
&lt;td class=&#34;tableblock halign-left valign-top&#34;&gt;&lt;p class=&#34;tableblock&#34;&gt;-&lt;/p&gt;&lt;/td&gt;
&lt;td class=&#34;tableblock halign-left valign-top&#34;&gt;&lt;p class=&#34;tableblock&#34;&gt;D&lt;/p&gt;&lt;/td&gt;
&lt;td class=&#34;tableblock halign-left valign-top&#34;&gt;&lt;p class=&#34;tableblock&#34;&gt;r, A, D&lt;/p&gt;&lt;/td&gt;
&lt;td class=&#34;tableblock halign-left valign-top&#34;&gt;&lt;p class=&#34;tableblock&#34;&gt;A, E&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&#34;tableblock halign-left valign-top&#34;&gt;&lt;p class=&#34;tableblock&#34;&gt;B&lt;/p&gt;&lt;/td&gt;
&lt;td class=&#34;tableblock halign-left valign-top&#34;&gt;&lt;p class=&#34;tableblock&#34;&gt;r, A, B&lt;/p&gt;&lt;/td&gt;
&lt;td class=&#34;tableblock halign-left valign-top&#34;&gt;&lt;p class=&#34;tableblock&#34;&gt;D&lt;/p&gt;&lt;/td&gt;
&lt;td class=&#34;tableblock halign-left valign-top&#34;&gt;&lt;p class=&#34;tableblock&#34;&gt;E&lt;/p&gt;&lt;/td&gt;
&lt;td class=&#34;tableblock halign-left valign-top&#34;&gt;&lt;p class=&#34;tableblock&#34;&gt;r, A, E&lt;/p&gt;&lt;/td&gt;
&lt;td class=&#34;tableblock halign-left valign-top&#34;&gt;&lt;p class=&#34;tableblock&#34;&gt;-&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;插入 φ 节点的算法如下：&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;algo:insert-phi-functions&#34; class=&#34;imageblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;img src=&#34;images/algo-insert-phi-functions.png&#34; alt=&#34;algo insert phi functions&#34;/&gt;
&lt;/div&gt;
&lt;div class=&#34;title&#34;&gt;Figure 2. 算法：插入 φ 节点（摘自 SSA Book）&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;这是典型的 BFS 算法。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;有几个注意点：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;ulist&#34;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;由于 φ 节点本身是变量的定义，因此可能存在一种情况，即插入 φ 节点后又需要递归地处理被修改节点的 DF；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;此处使用 &lt;code&gt;F&lt;/code&gt; 来避免在同一个 BB 中插入同一个变量的多个 φ 节点。这是因为同一变量不同 BB 的 DF 可能重合，而所有的情况最终都合并在同一个 φ 节点中处理，因此只要某一次处理某个 BB 的 DF 时插入了 φ 节点，后续就不需要再插入了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&#34;sidebarblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;div class=&#34;title&#34;&gt;Iterated Dominance Frontier&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;为了数学上的方便，先驱们给&lt;a href=&#34;#algo:insert-phi-functions&#34;&gt;算法：插入 φ 节点（摘自 SSA Book）&lt;/a&gt; 计算过程中涉及到的所有 BB 进行了单独的定义，称为“iterated dominance frontier”，具体定义如下：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;olist arabic&#34;&gt;
&lt;ol class=&#34;arabic&#34;&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;DF&lt;sub&gt;1&lt;/sub&gt;(S) = DF(S)&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;DF&lt;sub&gt;i+1&lt;/sub&gt;(S) = DF(UNION(S, DF&lt;sub&gt;i&lt;/sub&gt;(S)))&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;最后达到的不动点用 &lt;code&gt;DF&lt;sup&gt;+&lt;/sup&gt;(S)&lt;/code&gt; 表示，该集合即为某个变量的“iterated dominance frontier”。实际上就是 DF(S) 的传递闭包。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;例如 &lt;a href=&#34;#fig:df-ex-1&#34;&gt;Dominance Frontier 例子（1）&lt;/a&gt; 中，&lt;code&gt;DF&lt;sup&gt;+&lt;/sup&gt;({B, C, D}) = {A, D, E}&lt;/code&gt;。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;这样，上述算法就可以定义为在 &lt;code&gt;DF&lt;sup&gt;+&lt;/sup&gt;(S)&lt;/code&gt; 的起始处插入 φ 节点。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect2&#34;&gt;
&lt;h3 id=&#34;_dominator_tree&#34;&gt;Dominator Tree&lt;/h3&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;这里其实还遗留一个问题：如何计算 DF。当然你可以根据定义来做，不过如果能够设计更巧妙的数据结构，我们就能得到更简单的算法。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;quoteblock&#34;&gt;
&lt;blockquote&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Show me your flowchart and conceal your tables, and I shall continue to be mystified. Show me your tables, and I won’t usually need your flowchart; it’ll be obvious.&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;div class=&#34;attribution&#34;&gt;
— Fred P. Brooks&lt;br/&gt;
&lt;cite&gt;The Mythical Man Month (1975)&lt;/cite&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;这个更巧妙的数据结构就是“dominator tree”。先来直观的感受下。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;imageblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;img src=&#34;images/dominator-tree-cfg.png&#34; alt=&#34;dominator tree cfg&#34;/&gt;
&lt;/div&gt;
&lt;div class=&#34;title&#34;&gt;Figure 3. 示例 CFG&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;其 dominator tree 如下：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;imageblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;img src=&#34;images/dominator-tree-dgraph.png&#34; alt=&#34;dominator tree dgraph&#34;/&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;不过为了更好地支持 DF 的计算，我们需要在 dominator tree 的基础上加入一种称为 J-edge 的边，对于一条 J-edge a → b，a 不能够 strictly dominate b。扩展后的如下所示（用虚线表示）：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;imageblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;img src=&#34;images/dominator-tree-djgraph.png&#34; alt=&#34;dominator tree djgraph&#34;/&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;这里注意，对于一条 J-edge a → b，有如下事实：a 的任意祖先 x 都 strictly dominate a，同时由于 a 是 b 的前驱，那么对于所有不能够 strictly dominate b 的 x，b 必然在 DF(x) 中。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;然后，我们就可以定义算法了：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;imageblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;img src=&#34;images/algo-calc-df.png&#34; alt=&#34;algo calc df&#34;/&gt;
&lt;/div&gt;
&lt;div class=&#34;title&#34;&gt;Figure 4. 算法：计算 DF（摘自 SSA Book）&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect2&#34;&gt;
&lt;h3 id=&#34;_join_set&#34;&gt;Join Set&lt;/h3&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;对于给定的顶点集合 &lt;code&gt;S&lt;/code&gt;，&lt;code&gt;JOIN-SET(S)&lt;/code&gt; 是 S 中所有 join node 的集合。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;所谓“join node”，是指能够从 S 中两个或多个不同的顶点经过不相交的路径到达的顶点。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;实际上还有另一种更加直观地表示。我们先来进一步解读一下 DF 的定义。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_变量重命名&#34;&gt;变量重命名&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;重命名阶段基本上就是对 CFG 进行 DFS（当然，DFS 的路径就是 dominator tree）。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;imageblock text-center&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;img src=&#34;images/algo-rename-vars.png&#34; alt=&#34;algo rename vars&#34;/&gt;
&lt;/div&gt;
&lt;div class=&#34;title&#34;&gt;Figure 5. 算法：重命名变量（摘自 &lt;a href=&#34;https://www.cs.utexas.edu/users/mckinley/380C/lecs/07.pdf:&#34;&gt;CS380C Lec. 7 的 slide&lt;/a&gt;）&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;admonitionblock tip&#34;&gt;
&lt;table&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td class=&#34;icon&#34;&gt;
&lt;i class=&#34;fa icon-tip&#34; title=&#34;Tip&#34;&gt;&lt;/i&gt;
&lt;/td&gt;
&lt;td class=&#34;content&#34;&gt;
SSA Book 的变量重命名算法没有常见 DFS 的递归结构，理解起来不够直观。
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;其中：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;ulist&#34;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Stacks 是一个从变量 V 到栈的映射，栈顶是 V 最近定义的序号，Stacks[*] 初始为空；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;GenName 逻辑如下：&lt;/p&gt;
&lt;div class=&#34;ulist&#34;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Counters 是一个从变量 V 到分配给该变量下一个定义的序号的映射，Counters[*] 初始值为 0；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&#34;imageblock text-center&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;img src=&#34;images/algo-rename-vars-gen-name.png&#34; alt=&#34;algo rename vars gen name&#34;/&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;这里需要注意循环的顺序：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;ulist&#34;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;φ-node 是在 BB 的起始部分插入的，当前 BB 可能用得到 φ 的结果，因此需要把处理 φ 节点的循环放在最前面&lt;/p&gt;
&lt;div class=&#34;ulist&#34;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;这里其实存在一个小小的问题：如果先将 φ-node 的 LHS 重命名，后续在替换 RHS 的时候，是否会自己引用自己？答案是不会，φ-node 的 RHS 中的各个变量在处理 DT 中的父节点已经进行了替换，见最外层的第 3 个循环。这又引出一个问题：entry 没有父节点，怎么保证 φ-node 的 RHS 被处理呢？答案是，不需要处理，因为 entry 不可能有 φ-node&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;处理完某 BB 的 φ-node 后，接下来就是处理普通的指令（这里称为“Statement”），这里嵌套的循环也同样需要注意顺序：先替换，再重命名，否则就有可能自己引用自己；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;递归结束后，还需要将本 BB 引入的新名字退栈。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_案例研究go_编译器的_ssa_构造&#34;&gt;案例研究：Go 编译器的 SSA 构造&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;TODO&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

      </description>
    </item>
    
  </channel>
</rss>
