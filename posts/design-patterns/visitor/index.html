<!doctype html><html lang=zh-cn><head><title>设计模式之 Visitor · rhanqtl</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="rhanqtl"><meta name=description content="-"><meta name=keywords content="blog,developer,personal,博客,开发者,个人网站"><meta name=twitter:card content="summary"><meta name=twitter:title content="设计模式之 Visitor"><meta name=twitter:description content="-"><meta property="og:title" content="设计模式之 Visitor"><meta property="og:description" content="-"><meta property="og:type" content="article"><meta property="og:url" content="https://rhanqtl.github.io/posts/design-patterns/visitor/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-01-13T15:09:31+08:00"><meta property="article:modified_time" content="2023-01-13T15:09:31+08:00"><link rel=canonical href=https://rhanqtl.github.io/posts/design-patterns/visitor/><link rel=preload href="/fonts/forkawesome-webfont.woff2?v=1.2.0" as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.0669b62fc2c181a12a4ba10be9984e385c9a5e83dc7cb7ae3759ad0b98d7e8b2.css integrity="sha256-Bmm2L8LBgaEqS6EL6ZhOOFyaXoPcfLeuN1mtC5jX6LI=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/molokai.min.5a772179137f76a20e9f3b85125ac4d4b2ba9e877e72fc48b5434a0a88eca640.css integrity="sha256-WncheRN/dqIOnzuFElrE1LK6nod+cvxItUNKCojspkA=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/custom.min.79e5c878b74c6420a9af1e46d76fc5c90af4569034eea66cef6d2358f4111a6d.css integrity="sha256-eeXIeLdMZCCprx5G12/FyQr0VpA07qZs720jWPQRGm0=" crossorigin=anonymous media=screen><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5><meta name=generator content="Hugo 0.111.3"></head><body class="preload-transitions colorscheme-light"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=/>rhanqtl</a>
<input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/posts/>原创博文</a></li><li class=navigation-item><a class=navigation-link href=/translations/>翻译</a></li><li class=navigation-item><a class=navigation-link href=/poems/>喜欢的诗歌</a></li><li class=navigation-item><a class=navigation-link href=/projects/>作品</a></li><li class=navigation-item><a class=navigation-link href=/about/>关于我</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://rhanqtl.github.io/posts/design-patterns/visitor/>设计模式之 Visitor</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa fa-calendar" aria-hidden=true></i>
<time datetime=2023-01-13T15:09:31+08:00>January 13, 2023</time></span>
<span class=reading-time><i class="fa fa-clock-o" aria-hidden=true></i>
阅读时间：5 分钟</span></div><div class=tags><i class="fa fa-tag" aria-hidden=true></i>
<span class=tag><a href=/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/>设计模式</a></span>
<span class=separator>•</span>
<span class=tag><a href=/tags/design-pattern/>Design Pattern</a></span></div></div></header><div class=post-content><h1 id=动机>动机
<a class=heading-link href=#%e5%8a%a8%e6%9c%ba><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h1><p>思考一下，如果你需要根据参数的类型，选择合适的行为，会如何做？</p><p>整篇文章会以对 AST 进行求值举例，其中 AST 定义如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> abc
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> typing <span style=color:#f92672>import</span> Union
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>LiteralValueType <span style=color:#f92672>=</span> Union[int, float, bool]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Expr</span>(abc<span style=color:#f92672>.</span>ABC):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pass</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Literal</span>(Expr):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __init__(self, value: LiteralValueType):
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>value <span style=color:#f92672>=</span> value
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UnaryExpr</span>(Expr):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __init__(self, op: str, x: Expr):
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>op <span style=color:#f92672>=</span> op
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>x <span style=color:#f92672>=</span> x
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>BinaryExpr</span>(Expr):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __init__(self, lhs: Expr, rhs: Expr, op: str):
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>lhs <span style=color:#f92672>=</span> lhs
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>rhs <span style=color:#f92672>=</span> rhs
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>op <span style=color:#f92672>=</span> op
</span></span></code></pre></div><p>一种非常容易想到的方式是利用反射机制：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># The code requires Python 3.10 and above</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>my_eval</span>(e: Expr) <span style=color:#f92672>-&gt;</span> LiteralValueType:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>_eval_unary</span>(op, x) <span style=color:#f92672>-&gt;</span> LiteralValueType:
</span></span><span style=display:flex><span>        match op:
</span></span><span style=display:flex><span>            case <span style=color:#e6db74>&#34;-&#34;</span>:   <span style=color:#66d9ef>return</span> x
</span></span><span style=display:flex><span>            case <span style=color:#e6db74>&#34;not&#34;</span>: <span style=color:#66d9ef>return</span> <span style=color:#f92672>not</span> x
</span></span><span style=display:flex><span>            case _    : <span style=color:#66d9ef>raise</span> <span style=color:#a6e22e>Exception</span>(<span style=color:#e6db74>&#34;unsupported unary operator: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span><span style=color:#f92672>.</span>format(op))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>_eval_binary</span>(op, lhs, rhs) <span style=color:#f92672>-&gt;</span> LiteralValueType:
</span></span><span style=display:flex><span>        match op:
</span></span><span style=display:flex><span>            case <span style=color:#e6db74>&#34;+&#34;</span>:   <span style=color:#66d9ef>return</span> lhs <span style=color:#f92672>+</span> rhs
</span></span><span style=display:flex><span>            case <span style=color:#e6db74>&#34;-&#34;</span>:   <span style=color:#66d9ef>return</span> lhs <span style=color:#f92672>-</span> rhs
</span></span><span style=display:flex><span>            case <span style=color:#e6db74>&#34;*&#34;</span>:   <span style=color:#66d9ef>return</span> lhs <span style=color:#f92672>*</span> rhs
</span></span><span style=display:flex><span>            case <span style=color:#e6db74>&#34;/&#34;</span>:   <span style=color:#66d9ef>return</span> lhs <span style=color:#f92672>/</span> rhs
</span></span><span style=display:flex><span>            case <span style=color:#e6db74>&#34;and&#34;</span>: <span style=color:#66d9ef>return</span> lhs <span style=color:#f92672>and</span> rhs
</span></span><span style=display:flex><span>            case <span style=color:#e6db74>&#34;or&#34;</span>:  <span style=color:#66d9ef>return</span> lhs <span style=color:#f92672>or</span> rhs
</span></span><span style=display:flex><span>            case _:     <span style=color:#66d9ef>raise</span> <span style=color:#a6e22e>Exception</span>(<span style=color:#e6db74>&#34;unsupported binary operator: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span><span style=color:#f92672>.</span>format(op))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    match type(e):
</span></span><span style=display:flex><span>        case Literal:    <span style=color:#66d9ef>return</span> e<span style=color:#f92672>.</span>value
</span></span><span style=display:flex><span>        case UnaryExpr:  <span style=color:#66d9ef>return</span> _eval_unary(e<span style=color:#f92672>.</span>op, my_eval(e<span style=color:#f92672>.</span>x))
</span></span><span style=display:flex><span>        case BinaryExpr: <span style=color:#66d9ef>return</span> _eval_binary(e<span style=color:#f92672>.</span>op, my_eval(e<span style=color:#f92672>.</span>lhs), my_eval(e<span style=color:#f92672>.</span>rhs))
</span></span><span style=display:flex><span>        case _:          <span style=color:#66d9ef>raise</span> <span style=color:#a6e22e>Exception</span>(<span style=color:#e6db74>&#34;unknown expression type: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span><span style=color:#f92672>.</span>format(type(e)))
</span></span></code></pre></div><p>这种方式的优点在于非常明确，但是缺点如下：</p><ul><li>在不支持反射的语言中（例如，C 和 C++），这种方式很难实现（当然，在 C++ 中你可以用 <code>dynamic_cast</code>；对于 C，我能想到的一种补救方式是每个 <code>struct</code> 关联一个标签，不过既容易出错，又会增加运行期开销，属于雪上加霜）</li><li>缺少可扩展性。一方面，如果增加新的节点类型，就需要在 <code>my_eval</code> 函数中增加相应的分支；另一方面，如果想要支持对 AST 的其他操作，完全没有可以复用的内容</li></ul><blockquote><p>关于反射的效率，参见 StackOverflow 的<a href=https://stackoverflow.com/questions/3377576/if-reflection-is-inefficient-when-is-it-most-appropriate class=external-link target=_blank rel=noopener>这个问题</a>和<a href=https://softwareengineering.stackexchange.com/questions/143205/reflection-is-using-reflection-still-bad-or-slow-what-has-changed-with-ref class=external-link target=_blank rel=noopener>这个问题</a></p></blockquote><p>这里的核心问题在于：在有 sub-typing 的情况下，如何根据运行期对象的实际类型进行派发，Visitor 模式很好地解决了这个问题。不过，在正式进入 Visitor 模式之前，我们需要先来了解一下静态派发（static dispatching）和动态派发（dynamic dispatching）。</p><blockquote><p>可能会有些读者认为将求值的功能分散到各个 <code>*Expr</code> 中更好：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Expr</span>(abc<span style=color:#f92672>.</span>ABC):
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>@abc.abstractmethod</span>
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>do_eval</span>() <span style=color:#f92672>-&gt;</span> LiteralValueType: <span style=color:#66d9ef>pass</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Literal</span>(Expr):
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>do_eval</span>(self):
</span></span><span style=display:flex><span>       <span style=color:#66d9ef>return</span> self<span style=color:#f92672>.</span>value
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UnaryExpr</span>(Expr):
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>do_eval</span>(self):
</span></span><span style=display:flex><span>       match self<span style=color:#f92672>.</span>op:
</span></span><span style=display:flex><span>           case <span style=color:#e6db74>&#34;-&#34;</span>:   <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span>self<span style=color:#f92672>.</span>x<span style=color:#f92672>.</span>do_eval()
</span></span><span style=display:flex><span>           case <span style=color:#e6db74>&#34;not&#34;</span>: <span style=color:#66d9ef>return</span> <span style=color:#f92672>not</span> self<span style=color:#f92672>.</span>x<span style=color:#f92672>.</span>do_eval()
</span></span><span style=display:flex><span>           case _:     <span style=color:#66d9ef>raise</span> <span style=color:#a6e22e>Exception</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>BinaryExpr</span>(Expr):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>do_eval</span>(self):
</span></span><span style=display:flex><span>        match self<span style=color:#f92672>.</span>op:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>pass</span>
</span></span></code></pre></div><p>这样的设计有两个问题：</p><ul><li>“求值”（至少我认为）不是 <code>*Expr</code> 的职责，<code>*Expr</code> 的职责是表示 AST 的数据结构，不符合单一职责原则</li><li>假设将求值的功能放到了 <code>*Expr</code> 中，如果后续有其他需求（比如打印 AST），需要再次修改所有的 <code>*Expr</code>，这样不符合开闭原则</li></ul></blockquote><h1 id=静态派发和动态派发>静态派发和动态派发
<a class=heading-link href=#%e9%9d%99%e6%80%81%e6%b4%be%e5%8f%91%e5%92%8c%e5%8a%a8%e6%80%81%e6%b4%be%e5%8f%91><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h1><h2 id=静态派发>静态派发
<a class=heading-link href=#%e9%9d%99%e6%80%81%e6%b4%be%e5%8f%91><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h2><p>所谓静态派发，就是根据编译期的声明类型选择合适的方法，例如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>using</span> Time <span style=color:#f92672>=</span> <span style=color:#66d9ef>int64_t</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DateTimeFormatter</span> {
</span></span><span style=display:flex><span> <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>virtual</span> std<span style=color:#f92672>::</span>string format(<span style=color:#66d9ef>const</span> Time <span style=color:#f92672>&amp;</span>t) <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>virtual</span> <span style=color:#f92672>~</span>DateTimeFormatter() {}
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>StandardDateTimeFormatter</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>public</span> DateTimeFormatter {
</span></span><span style=display:flex><span> <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>  std<span style=color:#f92672>::</span>string format(<span style=color:#66d9ef>const</span> Time <span style=color:#f92672>&amp;</span>t) <span style=color:#66d9ef>override</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;2006-01-02 15:04:05.006&#34;</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>virtual</span> <span style=color:#f92672>~</span>StandardDateTimeFormatter() {}
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>AmericanDateTimeFormatter</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>public</span> DateTimeFormatter {
</span></span><span style=display:flex><span> <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>  std<span style=color:#f92672>::</span>string format(<span style=color:#66d9ef>const</span> Time <span style=color:#f92672>&amp;</span>t) <span style=color:#66d9ef>override</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;Jan. 02, 2006 - 15:04:05&#34;</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>virtual</span> <span style=color:#f92672>~</span>AmericanDateTimeFormatter() {}
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>如果使用如下调用：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>foo</span>(<span style=color:#66d9ef>const</span> DateTimeFormatter <span style=color:#f92672>&amp;</span>f) {
</span></span><span style=display:flex><span>  std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;abstract&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>foo</span>(<span style=color:#66d9ef>const</span> StandardDateTimeFormatter <span style=color:#f92672>&amp;</span>f) {
</span></span><span style=display:flex><span>  std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;standard&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>foo</span>(<span style=color:#66d9ef>const</span> AmericanDateTimeFormatter <span style=color:#f92672>&amp;</span>f) {
</span></span><span style=display:flex><span>  std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;american&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>  std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;name of formatter: &#34;</span>;
</span></span><span style=display:flex><span>  std<span style=color:#f92672>::</span>string name;
</span></span><span style=display:flex><span>  std<span style=color:#f92672>::</span>cin <span style=color:#f92672>&gt;&gt;</span> name;
</span></span><span style=display:flex><span>  DateTimeFormatter <span style=color:#f92672>*</span>f;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (name <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;standard&#34;</span>) {
</span></span><span style=display:flex><span>    f <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> StandardDateTimeFormatter {};
</span></span><span style=display:flex><span>  } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (name <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;american&#34;</span>) {
</span></span><span style=display:flex><span>    f <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> AmericanDateTimeFormatter {};
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  foo(<span style=color:#f92672>*</span>f);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>delete</span> f;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>总是会打印 <code>abstract</code>，这是因为调用 <code>foo</code> 的哪个重载是在编译期确定的，而编译器唯一能够确切知道的信息就是 <code>f</code> 的类型为 <code>DateTimeFormatter</code>，所以就会选择第一个重载。</p><h2 id=动态派发>动态派发
<a class=heading-link href=#%e5%8a%a8%e6%80%81%e6%b4%be%e5%8f%91><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h2><p>与静态派发相反，动态派发是根据运行期的实际类型选择方法，例如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>  std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;name of formatter: &#34;</span>;
</span></span><span style=display:flex><span>  std<span style=color:#f92672>::</span>string name;
</span></span><span style=display:flex><span>  std<span style=color:#f92672>::</span>cin <span style=color:#f92672>&gt;&gt;</span> name;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  DateTimeFormatter <span style=color:#f92672>*</span>f;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (name <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;standard&#34;</span>) {
</span></span><span style=display:flex><span>    f <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> StandardDateTimeFormatter {};
</span></span><span style=display:flex><span>  } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (name <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;american&#34;</span>) {
</span></span><span style=display:flex><span>    f <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> AmericanDateTimeFormatter {};
</span></span><span style=display:flex><span>  } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>abort();
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  f<span style=color:#f92672>-&gt;</span>format();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>delete</span> f;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>如果输入 <code>standard</code> 就会打印 <code>2006 ...</code>，如果输入 <code>american</code> 就会打印 <code>Jan ...</code>。</p><blockquote><p>动态分派的实现机制参见[另一篇博文]({{ ref &ldquo;/posts/how-dynamic-dispatching-works&rdquo; }})</p></blockquote><h1 id=visitor-模式>Visitor 模式
<a class=heading-link href=#visitor-%e6%a8%a1%e5%bc%8f><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h1><p>回忆一下我们要解决的问题：在有 sub-typing 的情况下，如何根据运行期对象的实际类型进行派发。Visitor 模式的一个核心立足点是，对象自己最清楚自己的类型，由此，Visitor 模式解决这个问题的方式是：让对象自己选择调用哪个方法。</p><p>回到 AST 的例子，我们需要对 AST 做一些改造，给所有的 expression 增加一个 <code>accept</code> 方法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># 我们的类定义出现了循环引用，这个 import 可以解决</span>
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> __future__ <span style=color:#f92672>import</span> annotations
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Expr</span>(abc<span style=color:#f92672>.</span>ABC):
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@abc.abstractmethod</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>accept</span>(self, v: Visitor): <span style=color:#66d9ef>pass</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Literal</span>(Expr):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>accept</span>(self, v: Visitor):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> v<span style=color:#f92672>.</span>visit_literal(self)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UnaryExpr</span>(Expr):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>accept</span>(self, v: Visitor):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> v<span style=color:#f92672>.</span>visit_unary_expr(self)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>BinaryExpr</span>(Expr):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>accept</span>(self, v: Visitor):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> v<span style=color:#f92672>.</span>visit_binary_expr(self)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Visitor</span>(abc<span style=color:#f92672>.</span>ABC):
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    Although this class is unnecessary (thanks to so-called duck-typing),
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    showing its definition makes it more explicit
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@abc.abstractmethod</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>visit_literal</span>(self, n: Literal): <span style=color:#66d9ef>pass</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@abc.abstractmethod</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>visit_unary_expr</span>(self, expr: UnaryExpr): <span style=color:#66d9ef>pass</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@abc.abstractmethod</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>visit_binary_expr</span>(self, expr: BinaryExpr): <span style=color:#66d9ef>pass</span>
</span></span></code></pre></div><p>这样，我们就能这样改写求值功能：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>EvalVisitor</span>(Visitor):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>visit_literal</span>(self, n: Literal):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> n<span style=color:#f92672>.</span>value
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>visit_unary_expr</span>(self, expr: UnaryExpr):
</span></span><span style=display:flex><span>        match expr<span style=color:#f92672>.</span>op:
</span></span><span style=display:flex><span>            case <span style=color:#e6db74>&#34;-&#34;</span>:   <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span>expr<span style=color:#f92672>.</span>x<span style=color:#f92672>.</span>accept(self)
</span></span><span style=display:flex><span>            case <span style=color:#e6db74>&#34;not&#34;</span>: <span style=color:#66d9ef>return</span> <span style=color:#f92672>not</span> expr<span style=color:#f92672>.</span>x<span style=color:#f92672>.</span>accept(self)
</span></span><span style=display:flex><span>            case _:     <span style=color:#66d9ef>raise</span> <span style=color:#a6e22e>Exception</span>(<span style=color:#e6db74>&#34;unsupported unary operator: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span><span style=color:#f92672>.</span>format(expr<span style=color:#f92672>.</span>op))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>visit_binary_expr</span>(self, expr: BinaryExpr):
</span></span><span style=display:flex><span>        match expr<span style=color:#f92672>.</span>op:
</span></span><span style=display:flex><span>            case <span style=color:#e6db74>&#34;+&#34;</span>:   <span style=color:#66d9ef>return</span> expr<span style=color:#f92672>.</span>lhs<span style=color:#f92672>.</span>accept(self) <span style=color:#f92672>+</span> expr<span style=color:#f92672>.</span>rhs<span style=color:#f92672>.</span>accept(self)
</span></span><span style=display:flex><span>            case <span style=color:#e6db74>&#34;-&#34;</span>:   <span style=color:#66d9ef>return</span> expr<span style=color:#f92672>.</span>lhs<span style=color:#f92672>.</span>accept(self) <span style=color:#f92672>-</span> expr<span style=color:#f92672>.</span>rhs<span style=color:#f92672>.</span>accept(self)
</span></span><span style=display:flex><span>            case <span style=color:#e6db74>&#34;*&#34;</span>:   <span style=color:#66d9ef>return</span> expr<span style=color:#f92672>.</span>lhs<span style=color:#f92672>.</span>accept(self) <span style=color:#f92672>*</span> expr<span style=color:#f92672>.</span>rhs<span style=color:#f92672>.</span>accept(self)
</span></span><span style=display:flex><span>            case <span style=color:#e6db74>&#34;/&#34;</span>:   <span style=color:#66d9ef>return</span> expr<span style=color:#f92672>.</span>lhs<span style=color:#f92672>.</span>accept(self) <span style=color:#f92672>/</span> expr<span style=color:#f92672>.</span>rhs<span style=color:#f92672>.</span>accept(self)
</span></span><span style=display:flex><span>            case <span style=color:#e6db74>&#34;and&#34;</span>: <span style=color:#66d9ef>return</span> expr<span style=color:#f92672>.</span>lhs<span style=color:#f92672>.</span>accept(self) <span style=color:#f92672>and</span> expr<span style=color:#f92672>.</span>rhs<span style=color:#f92672>.</span>accept(self)
</span></span><span style=display:flex><span>            case <span style=color:#e6db74>&#34;or&#34;</span>:  <span style=color:#66d9ef>return</span> expr<span style=color:#f92672>.</span>lhs<span style=color:#f92672>.</span>accept(self) <span style=color:#f92672>or</span> expr<span style=color:#f92672>.</span>rhs<span style=color:#f92672>.</span>accept(self)
</span></span><span style=display:flex><span>            case _:     <span style=color:#66d9ef>raise</span> <span style=color:#a6e22e>Exception</span>(<span style=color:#e6db74>&#34;unsupported binary operator: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span><span style=color:#f92672>.</span>format(expr<span style=color:#f92672>.</span>op))
</span></span></code></pre></div><p>如下验证：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>expr <span style=color:#f92672>=</span> \
</span></span><span style=display:flex><span>    BinaryExpr(
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;+&#34;</span>,
</span></span><span style=display:flex><span>        BinaryExpr(
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;+&#34;</span>,
</span></span><span style=display:flex><span>            Literal(<span style=color:#ae81ff>1</span>),
</span></span><span style=display:flex><span>            BinaryExpr(
</span></span><span style=display:flex><span>                <span style=color:#e6db74>&#34;*&#34;</span>,
</span></span><span style=display:flex><span>                Literal(<span style=color:#ae81ff>2</span>),
</span></span><span style=display:flex><span>                Literal(<span style=color:#ae81ff>3</span>),
</span></span><span style=display:flex><span>            ),
</span></span><span style=display:flex><span>        ),
</span></span><span style=display:flex><span>        Literal(<span style=color:#ae81ff>4</span>),
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>print(expr<span style=color:#f92672>.</span>accept(EvalVisitor()))
</span></span></code></pre></div><p>需要注意的是，尽管我们用 AST 这种递归数据结构举例，但是 Visitor 模式也可适用于单个对象的情况。</p><h1 id=visitor-模式总是必须的吗>Visitor 模式总是必须的吗？
<a class=heading-link href=#visitor-%e6%a8%a1%e5%bc%8f%e6%80%bb%e6%98%af%e5%bf%85%e9%a1%bb%e7%9a%84%e5%90%97><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h1><p>答案自然是否定的。Paul Graham 有一场主题为<a href=http://www.norvig.com/design-patterns/ class=external-link target=_blank rel=noopener>“Design Patterns in Dynamic Programming”</a>的演讲提到，23 种设计模式中，有 16 种是可以通过语言内建的机制取代的，其中就包括 Visitor 模式。</p><h2 id=多分派>多分派
<a class=heading-link href=#%e5%a4%9a%e5%88%86%e6%b4%be><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h2><p>英文为“multiple dispatching”，也可称为“multimethod”，是指定义一组同名函数，在<strong>运行期</strong>根据<strong>所有</strong>参数的类型匹配调用目标（与编译期的函数重载相似，但不完全相同）。与多派发相对的是单派发（“single dispatch”），是指在运行期根据在其上调用方法的对象的类型选择合适的函数（也就是前文所说的“动态派发”）。</p><p>如果 Python 支持多分派，也许可以写成这样：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> sys
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Visitor</span>(abc<span style=color:#f92672>.</span>ABC):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>visit</span>(self, expr: BinaryExpr): <span style=color:#66d9ef>pass</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>visit</span>(self, expr: UnaryExpr): <span style=color:#66d9ef>pass</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>visit</span>(self, expr: Literal): <span style=color:#66d9ef>pass</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> __name__ <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;__main__&#34;</span>:
</span></span><span style=display:flex><span>    expr <span style=color:#f92672>=</span> parse_to_ast(sys<span style=color:#f92672>.</span>argv[<span style=color:#ae81ff>1</span>])
</span></span><span style=display:flex><span>    EvalVisitor()<span style=color:#f92672>.</span>visit(expr)
</span></span></code></pre></div><p>实际上，Visitor 模式在某种程度上实现了基于 <code>v: Visitor</code> 和 <code>e: Expr</code> 的多分派，调用 <code>Expr::accept</code> 时是一次动态派发，调用 <code>Visitor::visit</code> 时是一次静态派发，所以理论上来讲可以通过增加分派次数实现支持更多参数的多分派。</p><p>除了解决开篇提出的基于反射的方案的几个缺点之外，Visitor 模式也充分利用了类型系统，降低了出错概率。</p><h1 id=从程序设计语言的角度看-visitor-模式>从程序设计语言的角度看 Visitor 模式
<a class=heading-link href=#%e4%bb%8e%e7%a8%8b%e5%ba%8f%e8%ae%be%e8%ae%a1%e8%af%ad%e8%a8%80%e7%9a%84%e8%a7%92%e5%ba%a6%e7%9c%8b-visitor-%e6%a8%a1%e5%bc%8f><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h1><h2 id=oop-和-fp-组织程序的方式>OOP 和 FP 组织程序的方式
<a class=heading-link href=#oop-%e5%92%8c-fp-%e7%bb%84%e7%bb%87%e7%a8%8b%e5%ba%8f%e7%9a%84%e6%96%b9%e5%bc%8f><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h2><p>所有的程序都包含类型和操作两个方面，然而 FP 和 OOP 组织二者的方式是不同的——FP 倾向于将对于多种类型的操作组织在一起，而 OOP 倾向于将多种操作组织在同一个类型中。假设现在有 A、B 和 C 三种类型，每种类型都有 foo、bar 和 baz 三种操作，我们可以画出如下的类型/操作矩阵：</p><table><thead><tr><th style=text-align:left>类型 \ 操作</th><th style=text-align:left>foo</th><th style=text-align:left>bar</th><th style=text-align:left>baz</th></tr></thead><tbody><tr><td style=text-align:left>A</td><td style=text-align:left></td><td style=text-align:left></td><td style=text-align:left></td></tr><tr><td style=text-align:left>B</td><td style=text-align:left></td><td style=text-align:left></td><td style=text-align:left></td></tr><tr><td style=text-align:left>C</td><td style=text-align:left></td><td style=text-align:left></td><td style=text-align:left></td></tr></tbody></table><p>OOP 的组织方式会是这样的：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Base</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>foo</span> ; <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>bar</span> ; <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>baz</span> ; <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>A</span> <span style=color:#f92672>&lt;</span> <span style=color:#66d9ef>Base</span> <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>B</span> <span style=color:#f92672>&lt;</span> <span style=color:#66d9ef>Base</span> <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>C</span> <span style=color:#f92672>&lt;</span> <span style=color:#66d9ef>Base</span> <span style=color:#66d9ef>end</span>
</span></span></code></pre></div><p>我们将其称为“按行”组织。而 FP 会是这样的：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>Base</span> { A, B, C, }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>foo</span>(x Base) -&gt; String {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>match</span> x {
</span></span><span style=display:flex><span>      A <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;A::foo&#34;</span>,
</span></span><span style=display:flex><span>      B <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;B::foo&#34;</span>,
</span></span><span style=display:flex><span>      C <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;C::foo&#34;</span>,
</span></span><span style=display:flex><span>    }.to_owned()
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>bar</span>(x: <span style=color:#a6e22e>Base</span>) -&gt; String { unimplemented!(); }
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>baz</span>(x: <span style=color:#a6e22e>Base</span>) -&gt; String { unimplemented!(); }
</span></span></code></pre></div><p>我们将其称为“按列”组织。</p><p>在 OOP 中，增加新类型是很容易的——只需要继承 <code>Base</code> 即可，而要增加操作，就会比较麻烦——可能需要在所有类中添加这个操作；而在 FP 中，增加新操作比较容易——只需要实现一个新的函数，在其中使用模式匹配即可，而要增加类型就会比较麻烦——需要在所有操作的模式匹配中增加这个新类型。</p><blockquote><p>前文提到的多分派可以容易的支持两个方向的扩展</p></blockquote><h2 id=visitor-模式的作用>Visitor 模式的作用
<a class=heading-link href=#visitor-%e6%a8%a1%e5%bc%8f%e7%9a%84%e4%bd%9c%e7%94%a8><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h2><p>Visitor 模式就改变了上述 OOP 难以增加新操作的问题——要增加一组新的操作，只需要创建一个新类，实现 <code>Visitor</code> 接口即可。当然，凡事都是有代价的，Visitor 模式让增加新类型变得困难了。延续上面 AST 的例子，如果要增加一个 <code>Variable</code> 节点，就需要在所有的 <code>Visitor</code> 中增加 <code>visit_variable</code> 方法。</p><blockquote><p>Visitor 模式使得可以在 OOP 中模拟 FP 的行为，那么有没有一种方式能够让我们在 FP 中模拟 OOP 的行为呢？</p><blockquote><p>这是<a href=https://craftinginterpreters.com/ class=external-link target=_blank rel=noopener>《Crafting Interpreters》</a>中的思考题</p></blockquote><ul><li>Ocaml 中提供了 <a href=https://ocaml.org/docs/modules class=external-link target=_blank rel=noopener>module 机制</a>，可以用来实现更加偏向于 OOP 风格的封装。</li><li>Haskell 的 <a href="https://book.realworldhaskell.org/read/using-typeclasses.html#:~:text=Typeclasses%20are%20among%20the%20most%20powerful%20features%20in,features%20such%20as%20equality%20testing%20and%20numeric%20operators." class=external-link target=_blank rel=noopener>typeclass</a> 也是这种组织方式（至少我理解是这样）</li><li>《Crafting Interpreters》也提供了一种方案：通过 tuple 或 record 维护一个类型所有的函数</li></ul></blockquote><h1 id=其他>其他
<a class=heading-link href=#%e5%85%b6%e4%bb%96><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h1><h1 id=与其他模式的关系>与其他模式的关系
<a class=heading-link href=#%e4%b8%8e%e5%85%b6%e4%bb%96%e6%a8%a1%e5%bc%8f%e7%9a%84%e5%85%b3%e7%b3%bb><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h1><p>由于 Visitor 模式通常操作的都是复合结构，所以该模式与 Composite 模式有很强的关系，以 AST 为例：</p><p><img src=./images/ast-composite.png alt></p><h1 id=杂项>杂项
<a class=heading-link href=#%e6%9d%82%e9%a1%b9><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h1><h2 id=简化-element-的定义>简化 Element 的定义
<a class=heading-link href=#%e7%ae%80%e5%8c%96-element-%e7%9a%84%e5%ae%9a%e4%b9%89><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h2><p>在 Python 3.x 中，可以如下实现：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> abc
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Visitable</span>(abc<span style=color:#f92672>.</span>ABCMeta):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>accept</span>(self, v: Visitor):
</span></span><span style=display:flex><span>        method <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;visit_&#34;</span> <span style=color:#f92672>+</span> type(self)<span style=color:#f92672>.</span>__name__
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> getattr(v, method)(self)
</span></span></code></pre></div><p>Ruby 中可以这样实现：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Visitable</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>accept</span> v
</span></span><span style=display:flex><span>    method <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;visit_&#34;</span> <span style=color:#f92672>+</span> self<span style=color:#f92672>.</span>class<span style=color:#f92672>.</span>name
</span></span><span style=display:flex><span>    v<span style=color:#f92672>.</span>send method<span style=color:#f92672>.</span>to_sym, self
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><blockquote><p>如果使用函数重载定义 <code>visit</code>，这种方法显然是行不通的，而且（就我的知识水平而言）使用重载的方式无法定义一个通用的 <code>Visitable</code> 类（因为静态派发）</p></blockquote><h2 id=参数传递>参数传递
<a class=heading-link href=#%e5%8f%82%e6%95%b0%e4%bc%a0%e9%80%92><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h2><p>我想到的方法：</p><ul><li>通过 <code>visit*</code> 可变参数实现</li><li>定义一个参数类，所有的参数组成其字段，这种方式可以改成定义一个 marker interface 然后通过类型转换的方式实现</li></ul><h1 id=参考>参考
<a class=heading-link href=#%e5%8f%82%e8%80%83><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h1><ol><li><a href=https://en.wikipedia.org/wiki/Visitor_pattern class=external-link target=_blank rel=noopener>Visitor pattern - Wikipedia</a></li><li><a href=https://en.wikipedia.org/wiki/Multiple_dispatch class=external-link target=_blank rel=noopener>Multiple dispatch - Wikipedia</a><ol><li>Julia 是一种支持多分派的语言，可以参考 <a href=https://www.matecdev.com/posts/julia-multiple-dispatch.html class=external-link target=_blank rel=noopener>https://www.matecdev.com/posts/julia-multiple-dispatch.html</a></li><li><a href=https://en.wikipedia.org/wiki/Double_dispatch class=external-link target=_blank rel=noopener>Double dispatch - Wikipedia</a></li></ol></li></ol></div><footer></footer></article></section></div><footer class=footer><section class=container>©
2023
rhanqtl
·
技术支持 <a href=https://gohugo.io/>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/>Coder</a>.</section></footer></main><script src=/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script></body></html>