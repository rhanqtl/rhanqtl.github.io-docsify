<!doctype html><html lang=zh-cn><head><title>用 Flex 和 Bison 实现一个计算器 · rhanqtl</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="rhanqtl"><meta name=description content="-"><meta name=keywords content="blog,developer,personal,博客,开发者,个人网站"><meta name=twitter:card content="summary"><meta name=twitter:title content="用 Flex 和 Bison 实现一个计算器"><meta name=twitter:description content="-"><meta property="og:title" content="用 Flex 和 Bison 实现一个计算器"><meta property="og:description" content="-"><meta property="og:type" content="article"><meta property="og:url" content="https://rhanqtl.github.io/posts/compilers/build-your-own-programming-language/01-flex-bison-intro/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-02-04T11:27:54+08:00"><meta property="article:modified_time" content="2023-02-04T11:27:54+08:00"><link rel=canonical href=https://rhanqtl.github.io/posts/compilers/build-your-own-programming-language/01-flex-bison-intro/><link rel=preload href="/fonts/forkawesome-webfont.woff2?v=1.2.0" as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.0669b62fc2c181a12a4ba10be9984e385c9a5e83dc7cb7ae3759ad0b98d7e8b2.css integrity="sha256-Bmm2L8LBgaEqS6EL6ZhOOFyaXoPcfLeuN1mtC5jX6LI=" crossorigin=anonymous media=screen><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5><meta name=generator content="Hugo 0.111.3"></head><body class="preload-transitions colorscheme-light"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=/>rhanqtl</a>
<input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/posts/>原创博文</a></li><li class=navigation-item><a class=navigation-link href=/translations/>翻译</a></li><li class=navigation-item><a class=navigation-link href=/poems/>喜欢的诗歌</a></li><li class=navigation-item><a class=navigation-link href=/projects/>作品</a></li><li class=navigation-item><a class=navigation-link href=/about/>关于我</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://rhanqtl.github.io/posts/compilers/build-your-own-programming-language/01-flex-bison-intro/>用 Flex 和 Bison 实现一个计算器</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa fa-calendar" aria-hidden=true></i>
<time datetime=2023-02-04T11:27:54+08:00>February 4, 2023</time></span>
<span class=reading-time><i class="fa fa-clock-o" aria-hidden=true></i>
阅读时间：4 分钟</span></div><div class=tags><i class="fa fa-tag" aria-hidden=true></i>
<span class=tag><a href=/tags/%E7%BC%96%E8%AF%91%E5%99%A8/>编译器</a></span>
<span class=separator>•</span>
<span class=tag><a href=/tags/lex/>Lex</a></span>
<span class=separator>•</span>
<span class=tag><a href=/tags/yacc/>Yacc</a></span>
<span class=separator>•</span>
<span class=tag><a href=/tags/flex/>Flex</a></span>
<span class=separator>•</span>
<span class=tag><a href=/tags/bison/>Bison</a></span></div></div></header><div class=post-content><blockquote><p>本文需要你有一定的 C/C++ 基础和编译原理基础，包括：了解 C/C++ 基本的编译模型，词法分析（会写正则表达式）、语法分析（至少能够定义文法，了解 BNF 更好）</p></blockquote><h1 id=词法规则定义>词法规则定义
<a class=heading-link href=#%e8%af%8d%e6%b3%95%e8%a7%84%e5%88%99%e5%ae%9a%e4%b9%89><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h1><p>Flex 文件包含三个部分：一些 C 语言的声明定义、匹配 token 的规则（正则表达式）和匹配成功时的动作，以及 C 函数定义，三个部分之间用 <code>%%</code> 分开，如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>%{
</span></span><span style=display:flex><span>  ... prologue ...
</span></span><span style=display:flex><span>%}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>... Bison declarations ...
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>%%
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>... grammar ...
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>%%
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>... epilogue ...
</span></span></code></pre></div><p>词法规则的第一部分如下：</p><pre tabindex=0><code class=language-flex data-lang=flex>%{
  #include &lt;stdlib.h&gt;

  #include &#34;calc.tab.h&#34;

  void yyerror(const char *fmt, ...);
%}

%option noyywrap nodefault

number  [0-9]+(\.[0-9]+)?([eE][-+]?[0-9]+)?
</code></pre><p>其中 <code>%{ ... %}</code> 内的部分会被原样拷贝到生成的 <code>.c</code> 文件中：</p><ul><li><code>#include "calc.tab.h"</code> 是 Bison 生成的头文件，其中包含 token 的定义和 C 函数的声明</li><li><code>yyerror</code> 是报告错误的函数，定义在语法规则文件中</li><li><code>%option noyywrap</code> 表示不需要默认定义 <code>yywrap</code> 函数，这个函数时早期的遗留，现在几乎不使用</li><li><code>%option nodefault</code> 表示禁用默认的 <code>main</code> 函数</li></ul><p>最后的 <code>number ...</code> 相当于给正则表达式起了个名字，后面可以通过名字引用。注意，不支持符号，这里跟常见的编程语言一致，认为负数实际上是对字面量应用取反运算符。</p><p>此法规则的第二部分如下：</p><pre tabindex=0><code class=language-flex data-lang=flex>%%

{number}    {
              yylval = atof(yytext);
              return NUM;
            }

[-+*/^()]   { return yytext[0]; }

\n          {
              yycolumn = 1;
              return yytext[0];
            }
[ \t\r\f]   ;

.           yyerror(&#34;invalid character&#34;);

%%
</code></pre><p>每一条规则都包含一个模式和一组动作。其中：</p><ul><li>第一个规则的 <code>number</code> 就是前一部分定义的正则表达式，其动作表示我们要将当前的 lexeme 转换为 <code>double</code> 赋给保存语义值的 yylval 变量，并返回 <code>NUM</code> 表示当前匹配到了 <code>NUM</code> 这个 token；</li><li>第二条规则匹配到的都是单字符的运算符，不需要额外的名字，表示原样返回对应的字符；</li><li>第四条规则的动作部分只有一个 <code>;</code>，表示将相关字符忽略掉，具体的，这里就是忽略除 <code>\n</code> 之外的空白符。</li><li>最后一条规则表示任何没有匹配的字符都要报错</li></ul><blockquote><p>Flex 有一个重要的限制是不支持 Unicode，如果想要支持 Unicode 只能自己实现词法分析器然后与语法分析器对接起来（通过 <code>yylex</code> 函数）。</p></blockquote><h1 id=语法规则定义>语法规则定义
<a class=heading-link href=#%e8%af%ad%e6%b3%95%e8%a7%84%e5%88%99%e5%ae%9a%e4%b9%89><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h1><p>为了实现运算符的优先级和结合性，对于数学表达式，教科书上通常会给出这样的文法：</p><pre tabindex=0><code>expr    → term
term    → term &#39;+&#39; factor | term &#39;-&#39; factor
factor  → factor &#39;*&#39; unary | factor &#39;/&#39; unary
unary   → primary | &#39;-&#39; unary
primary → NUM | &#39;(&#39; expr &#39;)&#39;
</code></pre><p>但是这种文法需要引入若干额外的名字（毕竟起名字是一件很难的事），而且关于优先级和结合性的信息是隐含的，不便于理解，因此 Bison 提供了一种简便的方式：</p><pre tabindex=0><code class=language-bison data-lang=bison>...

%left &#39;+&#39; &#39;-&#39;
%left &#39;*&#39; &#39;/&#39;
%nonassoc NEG
%right &#39;^&#39;

%%

expr : expr &#39;+&#39; expr
     | expr &#39;-&#39; expr
     | expr &#39;*&#39; expr
     | expr &#39;/&#39; expr
     | expr &#39;^&#39; expr
     | &#39;-&#39; expr %prec NEG

...
</code></pre><p>注意中间的 <code>%left</code> 这部分，<code>%left</code> 表示其后的运算符是左结合的，而从上到下的顺序表示优先级从高到低。</p><p>Bison 文件的总体结构与 Flex 文件相同，所不同的是具体的内容。</p><p>语法规则定义的第一部分如下：</p><pre tabindex=0><code>%{
  #include &lt;stdio.h&gt;
  #include &lt;math.h&gt;

  const char *PROMPT = &#34;=&gt; &#34;;

  int yylex(void);
  void yyerror(const char *format, ...);
%}

%define api.value.type {double}

%token NUM

%left &#39;+&#39; &#39;-&#39;
%left &#39;*&#39; &#39;/&#39;
%nonassoc NEG
%right &#39;^&#39;
</code></pre><p>与 Flex 文件相同，<code>%{ ... %}</code> 中的部分是一些 C 语言的头文件包含、常量定义和函数声明；<code>%define ...</code> 表示将 词法分析中保存语义值的变量 <code>yylval</code> 的类型 YYSTYPE 定义为 <code>double</code>；<code>%token NUM</code> 表示定义一个名为 <code>NUM</code> 的 token 类型；最后的几行就是前面提到的优先级和结合性的定义。</p><blockquote><p>你可能会好奇为什么 token 类别是由语法分析器定义的。我没有看到任何关于这一点的解释，但是有一个合理的推测：Flex 和 Bison 不是一起开发的，Bison 甚至不要求词法分析器一定是 Flex 生成的；语法分析过程需要了解 token 类别，这有一种做法是让词法分析器定义或者使用单独的头文件，但是如你所见，Bison 可以对 token 定义优先级，这一点使得无论如何 <code>.y</code> 文件中都会出现一些相关的定义，不如就直接由 Bison 定义。</p></blockquote><p>第二部分如下：</p><pre tabindex=0><code class=language-bison data-lang=bison>%%

input : %empty
      | input line { printf(PROMPT); }
      ;

line : &#39;\n&#39;
     | expr &#39;\n&#39;  { printf(&#34;%.17g\n&#34;, $1); }
     ;

expr : NUM                { $$ = $1; }
     | &#39;(&#39; expr &#39;)&#39;       { $$ = $2; }
     | expr &#39;+&#39; expr      { $$ = $1 + $3; }
     | expr &#39;-&#39; expr      { $$ = $1 - $3; }
     | expr &#39;*&#39; expr      { $$ = $1 * $3; }
     | expr &#39;/&#39; expr      { $$ = $1 / $3; }
     | expr &#39;^&#39; expr      { $$ = pow($1, $3); }
     | &#39;-&#39; expr %prec NEG { $$ = -$2; }
     ;
</code></pre><p>其中顶层规则 <code>input</code> 表示输入可以为空字符串（<code>%empty</code> 是 Bison 内置的表示空字符串的符号），也可以由若干个 <code>line</code> 组成，其动作在下一个部分解释；规则 <code>line</code> 表示一行可以直接给出换行，也可以有一个表达式；规则 <code>expr</code> 定义了我们支持的运算，其中 <code>$$</code> 表示产生式左侧所对应的语义值，$n 表示产生式右侧第 <code>n</code> 个终结符或非终结符的语义值。</p><p>这里注意 <code>expr</code> 的倒数第二个产生式，因为前一部分并没有定义一元 <code>-</code> 运算符的优先级，而仅定义了 <code>NEG</code> 这个优先级，这里需要用 <code>%prec NEG</code> 将该产生式与对应的优先级关联起来。</p><p>第三部分如下：</p><pre tabindex=0><code class=language-bison data-lang=bison>%%

int main(int argc, char *argv) {
  printf(PROMPT);
  return yyparse();
}

void yyerror(const char *fmt, ...) {
  fprintf(stderr, &#34;%s\n&#34;, fmt);
}
</code></pre><p><code>main</code> 函数中首先打印提示符，然后调用 <code>yyparse</code> 函数开始解析，由于在语法分析完成之前（即，遇到 EOF）函数 <code>yyparse</code> 都不会返回，这里不能在 <code>while</code> 循环体中打印提示符，而是需要在解析完成一行（即，一个表达式后）打印新的提示符（因为这时已经在 <code>line</code> 中打印了表达式的值，所以不会干扰）；函数 <code>yyerror</code> 就是报告错误函数的实现。</p><h1 id=改进错误恢复>改进：错误恢复
<a class=heading-link href=#%e6%94%b9%e8%bf%9b%e9%94%99%e8%af%af%e6%81%a2%e5%a4%8d><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h1><p>现在的计算器在出现语法错误时会直接崩溃，这不是我们期望的结果，一个健壮的计算器应该能够报告错误并从中恢复，为此，我们需要修改词法和语法的定义。</p><p>在词法规则定义中加入：</p><pre tabindex=0><code class=language-flex data-lang=flex>%{
  /* ... */
  int yycolumn = 1;

  #define YY_USER_ACTION \
    do { \
      yylloc.first_line = yylloc.last_line = yylineno; \
      yylloc.first_column = yycolumn; \
      yylloc.last_column = yycolumn + yyleng - 1; \
      yycolumn += yyleng;   \
    } while (0);
%}
</code></pre><p>其中：</p><ul><li>由于 Flex 只能够自动维护行号（即 <code>yylineno</code>），所以这里定义一个变量 <code>yycolumn</code> 来手动维护列号</li><li>Flex 在匹配到 token 并设置好 <code>yytext</code> 和 <code>yyleng</code> 后、在执行关联的语义动作之前，会展开 <code>YY_USER_ACTION</code> 钩子，给用户一些扩展空间，这里就是我们的定义，其中 <code>yylloc</code> 是用于表示 token 位置的结构体，其类型默认定义为</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> YYLTYPE {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> first_line;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> first_column;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> last_line;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> last_column;
</span></span><span style=display:flex><span>} YYLTYPE;
</span></span></code></pre></div><blockquote><p>可以通过如下方式覆盖默认的 <code>YYLTYPE</code> 定义：</p><pre tabindex=0><code class=language-bison data-lang=bison>%{
  #include &#34;location.h&#34;
%}

%define api.location.type {location_t}
</code></pre><p>在 Flex 文件中也需要修改：</p><pre tabindex=0><code class=language-flex data-lang=flex>%{
  // 顺序不能颠倒，否则 calc.tab.h 中找不到 `location_t` 这个符号
  #include &#34;location.h&#34;
  #include &#34;calc.tab.h&#34;
%}
</code></pre><p>原因见 <a href=https://stackoverflow.com/questions/10386567/yylloc-undefined-in-this-scope class=external-link target=_blank rel=noopener>StackOverflow</a></p><p>在另一个名为 <code>location.h</code> 的文件中，可以如下定义：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> __location {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span> filename;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> first_line;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> first_column;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> last_line;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> last_column;
</span></span><span style=display:flex><span>} <span style=color:#66d9ef>location_t</span>;
</span></span></code></pre></div></blockquote><p>在语法规则定义中加入：</p><pre tabindex=0><code class=language-bison data-lang=bison>%locations
/* ... */
</code></pre><p>表示开启位置特性</p><p>在 <code>line</code> 加入一条产生式：</p><pre tabindex=0><code class=language-bison data-lang=bison>line : error \n { yyerrok; }
</code></pre><p><code>error</code> 是 Bison 保留的关键字，用于表示错误情况，动作中的 <code>yyerrok</code> 表示忽略错误，恢复到正常状态。</p><p>将除法的产生式修改为：</p><pre tabindex=0><code class=language-bison data-lang=bison>expr : expr &#39;/&#39; expr { if ($3 != 0) {
                         $$ = $1 / $3;
                       } else {
                         $$ = INT_MIN;
                         fprintf(stderr, &#34;%d:%d-%d:%d: divide by zero\n&#34;,
                             @3.first_line, @3.first_column,
                             @3.last_line, @3.last_column);
                       }
                     }
</code></pre><p>我们会首先判断除数是否为 0，如果不为 0，正常进行除法运算，否则报错。其中 <code>@3</code> 是包含了产生式右侧第三个符号的位置的结构体（类型为 <code>YYLTYPE</code>）。</p><p>修改 <code>yyerror</code> 的定义：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>yyerror</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>fmt, ...) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>extern</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>yytext;
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>fprintf</span>(stderr, <span style=color:#e6db74>&#34;%d:%d-%d:%d: </span><span style=color:#ae81ff>\&#34;</span><span style=color:#e6db74>%s</span><span style=color:#ae81ff>\&#34;\n</span><span style=color:#e6db74>  error: %s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,
</span></span><span style=display:flex><span>      yylloc.first_line, yylloc.first_column,
</span></span><span style=display:flex><span>      yylloc.last_line, yylloc.last_column, yytext, fmt);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>由于 <code>yytext</code> 是词法分析器中的变量，这里需要将其声明为 <code>extern</code>，但是并不建议直接使用，因为语法分析过程可能会 look ahead 导致 <code>yytext</code> 并不是出错的 token。</p><p>这样我们就有了一个健壮的，能够报告错误的计算器。</p><h1 id=改进读取写入文件>改进：读取/写入文件
<a class=heading-link href=#%e6%94%b9%e8%bf%9b%e8%af%bb%e5%8f%96%e5%86%99%e5%85%a5%e6%96%87%e4%bb%b6><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h1><p>在语法规则定义中加入：</p><pre tabindex=0><code class=language-bison data-lang=bison>%{
  /* ... */
  #include &lt;stdbool.h&gt;

  const char *filename = &#34;&lt;interactive&gt;&#34;;
  bool interactive = true;
%}
</code></pre><p>修改 <code>input</code> 规则：</p><pre tabindex=0><code class=language-bison data-lang=bison>input : %empty
      | input line { if (interactive) {
                       printf(PROMPT);
                     }
                   }
      ;
</code></pre><p>修改 <code>main</code> 函数：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>argv[]) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>extern</span> FILE <span style=color:#f92672>*</span>yyin;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>extern</span> FILE <span style=color:#f92672>*</span>yyout;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (argc <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>    filename <span style=color:#f92672>=</span> argv[<span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>    yyin <span style=color:#f92672>=</span> <span style=color:#a6e22e>fopen</span>(filename, <span style=color:#e6db74>&#34;r&#34;</span>);
</span></span><span style=display:flex><span>    interactive <span style=color:#f92672>=</span> false;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (argc <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>2</span>) {
</span></span><span style=display:flex><span>    yyout <span style=color:#f92672>=</span> <span style=color:#a6e22e>fopen</span>(argv[<span style=color:#ae81ff>2</span>], <span style=color:#e6db74>&#34;w&#34;</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (interactive) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(PROMPT);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> ret <span style=color:#f92672>=</span> <span style=color:#a6e22e>yyparse</span>();
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>interactive) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fclose</span>(yyin);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fclose</span>(yyout);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> ret;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>此外，还需要将所有的输出改为 <code>fprintf(yyout, ...)</code></p><blockquote><p>不过输出到文件应该不是太重要，完全可以用 I/O 重定向实现，这里只是为了介绍 <code>yyout</code>.</p></blockquote><h1 id=结论>结论
<a class=heading-link href=#%e7%bb%93%e8%ae%ba><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h1><p>本文首先介绍了计算器的基本词法规则定义和基本语法规则定义，详细解释了各部分的含义。然后，借助 Flex 和 Bison 提供的功能，本文改进了该计算器，使得其更加健壮且能够报告出错位置。最后，本文为计算器增加了读取并解释文件以及将结果输出到文件的功能。</p><p>源码见 <a href=./src/src/calc.y>calc.y</a>
、<a href=./src/src/calc.l>calc.l</a>
、<a href=./src/include/location.h>location.h</a>
和 <a href=./src/Makefile>Makefile</a>
.</p><h1 id=参考>参考
<a class=heading-link href=#%e5%8f%82%e8%80%83><i class="fa fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h1><ol><li><a href=https://www.gnu.org/software/bison/manual/html_node/Location-Type.html class=external-link target=_blank rel=noopener>3.5.1 Data Type of Locations - Bison Manual</a></li></ol></div><footer></footer></article></section></div><footer class=footer><section class=container>©
2023
rhanqtl
·
技术支持 <a href=https://gohugo.io/>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/>Coder</a>.</section></footer></main><script src=/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script></body></html>